// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.2
// source: definition.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "";

export enum RFFSourceState {
  WAITING = 0,
  DEPOSITED = 1,
  UNRECOGNIZED = -1,
}

export function rFFSourceStateFromJSON(object: any): RFFSourceState {
  switch (object) {
    case 0:
    case "WAITING":
      return RFFSourceState.WAITING;
    case 1:
    case "DEPOSITED":
      return RFFSourceState.DEPOSITED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RFFSourceState.UNRECOGNIZED;
  }
}

export function rFFSourceStateToJSON(object: RFFSourceState): string {
  switch (object) {
    case RFFSourceState.WAITING:
      return "WAITING";
    case RFFSourceState.DEPOSITED:
      return "DEPOSITED";
    case RFFSourceState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CollectionFeeRequirement {
  UNDETERMINED = 0,
  YES = 1,
  NO = 2,
  UNRECOGNIZED = -1,
}

export function collectionFeeRequirementFromJSON(
  object: any,
): CollectionFeeRequirement {
  switch (object) {
    case 0:
    case "UNDETERMINED":
      return CollectionFeeRequirement.UNDETERMINED;
    case 1:
    case "YES":
      return CollectionFeeRequirement.YES;
    case 2:
    case "NO":
      return CollectionFeeRequirement.NO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CollectionFeeRequirement.UNRECOGNIZED;
  }
}

export function collectionFeeRequirementToJSON(
  object: CollectionFeeRequirement,
): string {
  switch (object) {
    case CollectionFeeRequirement.UNDETERMINED:
      return "UNDETERMINED";
    case CollectionFeeRequirement.YES:
      return "YES";
    case CollectionFeeRequirement.NO:
      return "NO";
    case CollectionFeeRequirement.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Universe {
  ETHEREUM = 0,
  FUEL = 1,
  SOLANA = 2,
  UNRECOGNIZED = -1,
}

export function universeFromJSON(object: any): Universe {
  switch (object) {
    case 0:
    case "ETHEREUM":
      return Universe.ETHEREUM;
    case 1:
    case "FUEL":
      return Universe.FUEL;
    case 2:
    case "SOLANA":
      return Universe.SOLANA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Universe.UNRECOGNIZED;
  }
}

export function universeToJSON(object: Universe): string {
  switch (object) {
    case Universe.ETHEREUM:
      return "ETHEREUM";
    case Universe.FUEL:
      return "FUEL";
    case Universe.SOLANA:
      return "SOLANA";
    case Universe.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
  /**
   * key is a value returned in PageResponse.next_key to begin
   * querying the next page most efficiently. Only one of offset or key
   * should be set.
   */
  key: Uint8Array;
  /**
   * offset is a numeric offset that can be used when key is unavailable.
   * It is less efficient than using key. Only one of offset or key should
   * be set.
   */
  offset: Long;
  /**
   * limit is the total number of results to be returned in the result page.
   * If left empty it will default to a value to be set by each app.
   */
  limit: Long;
  /**
   * count_total is set to true  to indicate that the result set should include
   * a count of the total number of items available for pagination in UIs.
   * count_total is only respected when offset is used. It is ignored when key
   * is set.
   */
  countTotal: boolean;
  /** reverse is set to true if results are to be returned in the descending order. */
  reverse: boolean;
}

/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
  /**
   * next_key is the key to be passed to PageRequest.key to
   * query the next page most efficiently. It will be empty if
   * there are no more results.
   */
  nextKey: Uint8Array;
  /**
   * total is total number of results available if PageRequest.count_total
   * was set, its value is undefined otherwise
   */
  total: Long;
}

export interface RFFSourcePair {
  universe: Universe;
  chainID: Uint8Array;
  tokenAddress: Uint8Array;
  value: Uint8Array;
  status: RFFSourceState;
  collectionFeeRequired: CollectionFeeRequirement;
}

export interface SignatureDatum {
  universe: Universe;
  address: Uint8Array;
  signature: Uint8Array;
  /** is to be left empty by the creator and is to be filled in during signature verification */
  hash: Uint8Array;
}

export interface RFFDestinationPair {
  tokenAddress: Uint8Array;
  /** amount */
  value: Uint8Array;
}

export interface RequestForFunds {
  id: Long;
  sources: RFFSourcePair[];
  destinationChainID: Uint8Array;
  destinations: RFFDestinationPair[];
  nonce: Uint8Array;
  expiry: Long;
  destinationUniverse: Universe;
  signatureData: SignatureDatum[];
  /** Cosmos user (???)/Cosmos internal fields */
  user: string;
  /** the EVM address that fulfilled it on the destination chain */
  fulfilledBy: Uint8Array;
  fulfilledAt: Long;
  deposited: boolean;
  fulfilled: boolean;
  /** todo: remove settled, using solver amount instead */
  settled: boolean;
  refunded: boolean;
  creationBlock: Long;
}

export interface MsgCreateRequestForFunds {
  sources: RFFSourcePair[];
  destinationUniverse: Universe;
  destinationChainID: Uint8Array;
  destinations: RFFDestinationPair[];
  nonce: Uint8Array;
  expiry: Long;
  user: string;
  signatureData: SignatureDatum[];
}

export interface MsgCreateRequestForFundsResponse {
  id: Long;
}

export interface QueryGetRequestForFundsRequest {
  id: Long;
}

export interface QueryGetRequestForFundsResponse {
  requestForFunds?: RequestForFunds | undefined;
}

export interface QueryAllRequestForFundsRequest {
  pagination?: PageRequest | undefined;
}

export interface QueryAllRequestForFundsResponse {
  requestForFunds: RequestForFunds[];
  pagination?: PageResponse | undefined;
}

export interface RouteFee {
  sourceUniverse: Universe;
  destinationUniverse: Universe;
  sourceChainID: Uint8Array;
  destinationChainID: Uint8Array;
  sourceTokenAddress: Uint8Array;
  destinationTokenAddress: Uint8Array;
  /** 7 â†” 9 are reserved for new fields */
  feeBP: number;
}

export interface SolverAddress {
  universe: Universe;
  address: Uint8Array;
  signature: Uint8Array;
}

export interface SolverData {
  cosmosAddress: string;
  advertisedFees: RouteFee[];
  addresses: SolverAddress[];
}

export interface QueryGetSolverDataRequest {
  cosmosAddress: string;
}

export interface QueryGetSolverDataResponse {
  solverData?: SolverData | undefined;
}

export interface QueryAllSolverDataRequest {
  pagination?: PageRequest | undefined;
}

export interface QueryAllSolverDataResponse {
  solverData: SolverData[];
  pagination?: PageResponse | undefined;
}

export interface MsgCreateSolverData {
  cosmosAddress: string;
  advertisedFees: RouteFee[];
  addresses: SolverAddress[];
}

export interface MsgCreateSolverDataResponse {}

export interface MsgUpdateSolverData {
  cosmosAddress: string;
  advertisedFees: RouteFee[];
  addresses: SolverAddress[];
}

export interface MsgUpdateSolverDataResponse {}

export interface Settlement {
  id: Uint8Array;
  universe: Universe;
  chainId: Uint8Array;
  amounts: Uint8Array[];
  tokenAddress: Uint8Array[];
  filler: Uint8Array[];
  success: boolean;
}

export interface QueryGetSettlementRequest {
  id: Long;
}

export interface QueryGetSettlementResponse {
  Settlement?: Settlement | undefined;
}

export interface QueryAllSettlementRequest {
  pagination?: PageRequest | undefined;
}

export interface QueryAllSettlementResponse {
  Settlement: Settlement[];
  pagination?: PageResponse | undefined;
}

export interface FixedFeeTuple {
  universe: Universe;
  chainID: Uint8Array;
  tokenAddress: Uint8Array;
  fee: Uint8Array;
}

export interface AdminFeeRecipient {
  universe: Universe;
  address: Uint8Array;
}

export interface ProtocolFees {
  feeBP: Long;
  collectionFees: FixedFeeTuple[];
  fulfilmentFees: FixedFeeTuple[];
  admin: string;
  feeRecipients: AdminFeeRecipient[];
}

export interface QueryGetProtocolFeesRequest {}

export interface QueryGetProtocolFeesResponse {
  ProtocolFees?: ProtocolFees | undefined;
}

export interface MsgCreateProtocolFees {
  creator: string;
  feeBP: Long;
  collectionFees: FixedFeeTuple[];
  fulfilmentFees: FixedFeeTuple[];
  feeRecipients: AdminFeeRecipient[];
}

export interface MsgCreateProtocolFeesResponse {}

export interface MsgUpdateProtocolFees {
  creator: string;
  feeBP: Long;
  collectionFees: FixedFeeTuple[];
  fulfilmentFees: FixedFeeTuple[];
  feeRecipients: AdminFeeRecipient[];
}

export interface MsgUpdateProtocolFeesResponse {}

export interface PriceOracleDatum {
  universe: Universe;
  chainID: Uint8Array;
  tokenAddress: Uint8Array;
  price: Uint8Array;
  decimals: number;
}

export interface PriceOracleData {
  priceData: PriceOracleDatum[];
}

export interface QueryGetPriceOracleDataRequest {}

export interface QueryGetPriceOracleDataResponse {
  PriceOracleData?: PriceOracleData | undefined;
}

export interface MsgRefundReq {
  creator: string;
  rffID: Long;
}

export interface MsgRefundReqResponse {}

export interface DepositVEPacket {
  id: Long;
  gasRefunded: boolean;
}

export interface FillVEPacket {
  id: Long;
  fillerAddress: Uint8Array;
  transactionHash: Uint8Array;
}

export interface MsgDoubleCheckTx {
  creator: string;
  txUniverse: Universe;
  txChainID: Uint8Array;
  packet?:
    | { $case: "depositPacket"; value: DepositVEPacket }
    | { $case: "fillPacket"; value: FillVEPacket }
    | undefined;
}

function createBasePageRequest(): PageRequest {
  return {
    key: new Uint8Array(0),
    offset: Long.UZERO,
    limit: Long.UZERO,
    countTotal: false,
    reverse: false,
  };
}

export const PageRequest: MessageFns<PageRequest> = {
  encode(
    message: PageRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (!message.offset.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.offset.toString());
    }
    if (!message.limit.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.limit.toString());
    }
    if (message.countTotal !== false) {
      writer.uint32(32).bool(message.countTotal);
    }
    if (message.reverse !== false) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.countTotal = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reverse = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageRequest {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.UZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.UZERO,
      countTotal: isSet(object.countTotal)
        ? globalThis.Boolean(object.countTotal)
        : false,
      reverse: isSet(object.reverse)
        ? globalThis.Boolean(object.reverse)
        : false,
    };
  },

  toJSON(message: PageRequest): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (!message.offset.equals(Long.UZERO)) {
      obj.offset = (message.offset || Long.UZERO).toString();
    }
    if (!message.limit.equals(Long.UZERO)) {
      obj.limit = (message.limit || Long.UZERO).toString();
    }
    if (message.countTotal !== false) {
      obj.countTotal = message.countTotal;
    }
    if (message.reverse !== false) {
      obj.reverse = message.reverse;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PageRequest>, I>>(base?: I): PageRequest {
    return PageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PageRequest>, I>>(
    object: I,
  ): PageRequest {
    const message = createBasePageRequest();
    message.key = object.key ?? new Uint8Array(0);
    message.offset =
      object.offset !== undefined && object.offset !== null
        ? Long.fromValue(object.offset)
        : Long.UZERO;
    message.limit =
      object.limit !== undefined && object.limit !== null
        ? Long.fromValue(object.limit)
        : Long.UZERO;
    message.countTotal = object.countTotal ?? false;
    message.reverse = object.reverse ?? false;
    return message;
  },
};

function createBasePageResponse(): PageResponse {
  return { nextKey: new Uint8Array(0), total: Long.UZERO };
}

export const PageResponse: MessageFns<PageResponse> = {
  encode(
    message: PageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nextKey.length !== 0) {
      writer.uint32(10).bytes(message.nextKey);
    }
    if (!message.total.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.total.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nextKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageResponse {
    return {
      nextKey: isSet(object.nextKey)
        ? bytesFromBase64(object.nextKey)
        : new Uint8Array(0),
      total: isSet(object.total) ? Long.fromValue(object.total) : Long.UZERO,
    };
  },

  toJSON(message: PageResponse): unknown {
    const obj: any = {};
    if (message.nextKey.length !== 0) {
      obj.nextKey = base64FromBytes(message.nextKey);
    }
    if (!message.total.equals(Long.UZERO)) {
      obj.total = (message.total || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PageResponse>, I>>(
    base?: I,
  ): PageResponse {
    return PageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PageResponse>, I>>(
    object: I,
  ): PageResponse {
    const message = createBasePageResponse();
    message.nextKey = object.nextKey ?? new Uint8Array(0);
    message.total =
      object.total !== undefined && object.total !== null
        ? Long.fromValue(object.total)
        : Long.UZERO;
    return message;
  },
};

function createBaseRFFSourcePair(): RFFSourcePair {
  return {
    universe: 0,
    chainID: new Uint8Array(0),
    tokenAddress: new Uint8Array(0),
    value: new Uint8Array(0),
    status: 0,
    collectionFeeRequired: 0,
  };
}

export const RFFSourcePair: MessageFns<RFFSourcePair> = {
  encode(
    message: RFFSourcePair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(18).bytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      writer.uint32(26).bytes(message.tokenAddress);
    }
    if (message.value.length !== 0) {
      writer.uint32(34).bytes(message.value);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.collectionFeeRequired !== 0) {
      writer.uint32(48).int32(message.collectionFeeRequired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RFFSourcePair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFSourcePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.collectionFeeRequired = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFSourcePair {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      tokenAddress: isSet(object.tokenAddress)
        ? bytesFromBase64(object.tokenAddress)
        : new Uint8Array(0),
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
      status: isSet(object.status) ? rFFSourceStateFromJSON(object.status) : 0,
      collectionFeeRequired: isSet(object.collectionFeeRequired)
        ? collectionFeeRequirementFromJSON(object.collectionFeeRequired)
        : 0,
    };
  },

  toJSON(message: RFFSourcePair): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.status !== 0) {
      obj.status = rFFSourceStateToJSON(message.status);
    }
    if (message.collectionFeeRequired !== 0) {
      obj.collectionFeeRequired = collectionFeeRequirementToJSON(
        message.collectionFeeRequired,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFSourcePair>, I>>(
    base?: I,
  ): RFFSourcePair {
    return RFFSourcePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFSourcePair>, I>>(
    object: I,
  ): RFFSourcePair {
    const message = createBaseRFFSourcePair();
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.collectionFeeRequired = object.collectionFeeRequired ?? 0;
    return message;
  },
};

function createBaseSignatureDatum(): SignatureDatum {
  return {
    universe: 0,
    address: new Uint8Array(0),
    signature: new Uint8Array(0),
    hash: new Uint8Array(0),
  };
}

export const SignatureDatum: MessageFns<SignatureDatum> = {
  encode(
    message: SignatureDatum,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    if (message.hash.length !== 0) {
      writer.uint32(34).bytes(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureDatum {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureDatum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureDatum {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
      hash: isSet(object.hash)
        ? bytesFromBase64(object.hash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SignatureDatum): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignatureDatum>, I>>(
    base?: I,
  ): SignatureDatum {
    return SignatureDatum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignatureDatum>, I>>(
    object: I,
  ): SignatureDatum {
    const message = createBaseSignatureDatum();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.hash = object.hash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRFFDestinationPair(): RFFDestinationPair {
  return { tokenAddress: new Uint8Array(0), value: new Uint8Array(0) };
}

export const RFFDestinationPair: MessageFns<RFFDestinationPair> = {
  encode(
    message: RFFDestinationPair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.tokenAddress.length !== 0) {
      writer.uint32(10).bytes(message.tokenAddress);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RFFDestinationPair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFDestinationPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFDestinationPair {
    return {
      tokenAddress: isSet(object.tokenAddress)
        ? bytesFromBase64(object.tokenAddress)
        : new Uint8Array(0),
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
    };
  },

  toJSON(message: RFFDestinationPair): unknown {
    const obj: any = {};
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFDestinationPair>, I>>(
    base?: I,
  ): RFFDestinationPair {
    return RFFDestinationPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFDestinationPair>, I>>(
    object: I,
  ): RFFDestinationPair {
    const message = createBaseRFFDestinationPair();
    message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestForFunds(): RequestForFunds {
  return {
    id: Long.UZERO,
    sources: [],
    destinationChainID: new Uint8Array(0),
    destinations: [],
    nonce: new Uint8Array(0),
    expiry: Long.UZERO,
    destinationUniverse: 0,
    signatureData: [],
    user: "",
    fulfilledBy: new Uint8Array(0),
    fulfilledAt: Long.UZERO,
    deposited: false,
    fulfilled: false,
    settled: false,
    refunded: false,
    creationBlock: Long.ZERO,
  };
}

export const RequestForFunds: MessageFns<RequestForFunds> = {
  encode(
    message: RequestForFunds,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    for (const v of message.sources) {
      RFFSourcePair.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.destinationChainID.length !== 0) {
      writer.uint32(26).bytes(message.destinationChainID);
    }
    for (const v of message.destinations) {
      RFFDestinationPair.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.expiry.toString());
    }
    if (message.destinationUniverse !== 0) {
      writer.uint32(72).int32(message.destinationUniverse);
    }
    for (const v of message.signatureData) {
      SignatureDatum.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.user !== "") {
      writer.uint32(810).string(message.user);
    }
    if (message.fulfilledBy.length !== 0) {
      writer.uint32(818).bytes(message.fulfilledBy);
    }
    if (!message.fulfilledAt.equals(Long.UZERO)) {
      writer.uint32(824).uint64(message.fulfilledAt.toString());
    }
    if (message.deposited !== false) {
      writer.uint32(832).bool(message.deposited);
    }
    if (message.fulfilled !== false) {
      writer.uint32(840).bool(message.fulfilled);
    }
    if (message.settled !== false) {
      writer.uint32(848).bool(message.settled);
    }
    if (message.refunded !== false) {
      writer.uint32(856).bool(message.refunded);
    }
    if (!message.creationBlock.equals(Long.ZERO)) {
      writer.uint32(872).int64(message.creationBlock.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestForFunds {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestForFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sources.push(RFFSourcePair.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationChainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinations.push(
            RFFDestinationPair.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiry = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.destinationUniverse = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.signatureData.push(
            SignatureDatum.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.fulfilledBy = reader.bytes();
          continue;
        }
        case 103: {
          if (tag !== 824) {
            break;
          }

          message.fulfilledAt = Long.fromString(
            reader.uint64().toString(),
            true,
          );
          continue;
        }
        case 104: {
          if (tag !== 832) {
            break;
          }

          message.deposited = reader.bool();
          continue;
        }
        case 105: {
          if (tag !== 840) {
            break;
          }

          message.fulfilled = reader.bool();
          continue;
        }
        case 106: {
          if (tag !== 848) {
            break;
          }

          message.settled = reader.bool();
          continue;
        }
        case 107: {
          if (tag !== 856) {
            break;
          }

          message.refunded = reader.bool();
          continue;
        }
        case 109: {
          if (tag !== 872) {
            break;
          }

          message.creationBlock = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestForFunds {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => RFFSourcePair.fromJSON(e))
        : [],
      destinationChainID: isSet(object.destinationChainID)
        ? bytesFromBase64(object.destinationChainID)
        : new Uint8Array(0),
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => RFFDestinationPair.fromJSON(e))
        : [],
      nonce: isSet(object.nonce)
        ? bytesFromBase64(object.nonce)
        : new Uint8Array(0),
      expiry: isSet(object.expiry) ? Long.fromValue(object.expiry) : Long.UZERO,
      destinationUniverse: isSet(object.destinationUniverse)
        ? universeFromJSON(object.destinationUniverse)
        : 0,
      signatureData: globalThis.Array.isArray(object?.signatureData)
        ? object.signatureData.map((e: any) => SignatureDatum.fromJSON(e))
        : [],
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      fulfilledBy: isSet(object.fulfilledBy)
        ? bytesFromBase64(object.fulfilledBy)
        : new Uint8Array(0),
      fulfilledAt: isSet(object.fulfilledAt)
        ? Long.fromValue(object.fulfilledAt)
        : Long.UZERO,
      deposited: isSet(object.deposited)
        ? globalThis.Boolean(object.deposited)
        : false,
      fulfilled: isSet(object.fulfilled)
        ? globalThis.Boolean(object.fulfilled)
        : false,
      settled: isSet(object.settled)
        ? globalThis.Boolean(object.settled)
        : false,
      refunded: isSet(object.refunded)
        ? globalThis.Boolean(object.refunded)
        : false,
      creationBlock: isSet(object.creationBlock)
        ? Long.fromValue(object.creationBlock)
        : Long.ZERO,
    };
  },

  toJSON(message: RequestForFunds): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => RFFSourcePair.toJSON(e));
    }
    if (message.destinationChainID.length !== 0) {
      obj.destinationChainID = base64FromBytes(message.destinationChainID);
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) =>
        RFFDestinationPair.toJSON(e),
      );
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      obj.expiry = (message.expiry || Long.UZERO).toString();
    }
    if (message.destinationUniverse !== 0) {
      obj.destinationUniverse = universeToJSON(message.destinationUniverse);
    }
    if (message.signatureData?.length) {
      obj.signatureData = message.signatureData.map((e) =>
        SignatureDatum.toJSON(e),
      );
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.fulfilledBy.length !== 0) {
      obj.fulfilledBy = base64FromBytes(message.fulfilledBy);
    }
    if (!message.fulfilledAt.equals(Long.UZERO)) {
      obj.fulfilledAt = (message.fulfilledAt || Long.UZERO).toString();
    }
    if (message.deposited !== false) {
      obj.deposited = message.deposited;
    }
    if (message.fulfilled !== false) {
      obj.fulfilled = message.fulfilled;
    }
    if (message.settled !== false) {
      obj.settled = message.settled;
    }
    if (message.refunded !== false) {
      obj.refunded = message.refunded;
    }
    if (!message.creationBlock.equals(Long.ZERO)) {
      obj.creationBlock = (message.creationBlock || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestForFunds>, I>>(
    base?: I,
  ): RequestForFunds {
    return RequestForFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestForFunds>, I>>(
    object: I,
  ): RequestForFunds {
    const message = createBaseRequestForFunds();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.sources =
      object.sources?.map((e) => RFFSourcePair.fromPartial(e)) || [];
    message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
    message.destinations =
      object.destinations?.map((e) => RFFDestinationPair.fromPartial(e)) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.expiry =
      object.expiry !== undefined && object.expiry !== null
        ? Long.fromValue(object.expiry)
        : Long.UZERO;
    message.destinationUniverse = object.destinationUniverse ?? 0;
    message.signatureData =
      object.signatureData?.map((e) => SignatureDatum.fromPartial(e)) || [];
    message.user = object.user ?? "";
    message.fulfilledBy = object.fulfilledBy ?? new Uint8Array(0);
    message.fulfilledAt =
      object.fulfilledAt !== undefined && object.fulfilledAt !== null
        ? Long.fromValue(object.fulfilledAt)
        : Long.UZERO;
    message.deposited = object.deposited ?? false;
    message.fulfilled = object.fulfilled ?? false;
    message.settled = object.settled ?? false;
    message.refunded = object.refunded ?? false;
    message.creationBlock =
      object.creationBlock !== undefined && object.creationBlock !== null
        ? Long.fromValue(object.creationBlock)
        : Long.ZERO;
    return message;
  },
};

function createBaseMsgCreateRequestForFunds(): MsgCreateRequestForFunds {
  return {
    sources: [],
    destinationUniverse: 0,
    destinationChainID: new Uint8Array(0),
    destinations: [],
    nonce: new Uint8Array(0),
    expiry: Long.UZERO,
    user: "",
    signatureData: [],
  };
}

export const MsgCreateRequestForFunds: MessageFns<MsgCreateRequestForFunds> = {
  encode(
    message: MsgCreateRequestForFunds,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.sources) {
      RFFSourcePair.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.destinationUniverse !== 0) {
      writer.uint32(16).int32(message.destinationUniverse);
    }
    if (message.destinationChainID.length !== 0) {
      writer.uint32(26).bytes(message.destinationChainID);
    }
    for (const v of message.destinations) {
      RFFDestinationPair.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.expiry.toString());
    }
    if (message.user !== "") {
      writer.uint32(58).string(message.user);
    }
    for (const v of message.signatureData) {
      SignatureDatum.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgCreateRequestForFunds {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateRequestForFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sources.push(RFFSourcePair.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.destinationUniverse = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationChainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinations.push(
            RFFDestinationPair.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiry = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.signatureData.push(
            SignatureDatum.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateRequestForFunds {
    return {
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => RFFSourcePair.fromJSON(e))
        : [],
      destinationUniverse: isSet(object.destinationUniverse)
        ? universeFromJSON(object.destinationUniverse)
        : 0,
      destinationChainID: isSet(object.destinationChainID)
        ? bytesFromBase64(object.destinationChainID)
        : new Uint8Array(0),
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => RFFDestinationPair.fromJSON(e))
        : [],
      nonce: isSet(object.nonce)
        ? bytesFromBase64(object.nonce)
        : new Uint8Array(0),
      expiry: isSet(object.expiry) ? Long.fromValue(object.expiry) : Long.UZERO,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      signatureData: globalThis.Array.isArray(object?.signatureData)
        ? object.signatureData.map((e: any) => SignatureDatum.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgCreateRequestForFunds): unknown {
    const obj: any = {};
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => RFFSourcePair.toJSON(e));
    }
    if (message.destinationUniverse !== 0) {
      obj.destinationUniverse = universeToJSON(message.destinationUniverse);
    }
    if (message.destinationChainID.length !== 0) {
      obj.destinationChainID = base64FromBytes(message.destinationChainID);
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) =>
        RFFDestinationPair.toJSON(e),
      );
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      obj.expiry = (message.expiry || Long.UZERO).toString();
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.signatureData?.length) {
      obj.signatureData = message.signatureData.map((e) =>
        SignatureDatum.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateRequestForFunds>, I>>(
    base?: I,
  ): MsgCreateRequestForFunds {
    return MsgCreateRequestForFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateRequestForFunds>, I>>(
    object: I,
  ): MsgCreateRequestForFunds {
    const message = createBaseMsgCreateRequestForFunds();
    message.sources =
      object.sources?.map((e) => RFFSourcePair.fromPartial(e)) || [];
    message.destinationUniverse = object.destinationUniverse ?? 0;
    message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
    message.destinations =
      object.destinations?.map((e) => RFFDestinationPair.fromPartial(e)) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.expiry =
      object.expiry !== undefined && object.expiry !== null
        ? Long.fromValue(object.expiry)
        : Long.UZERO;
    message.user = object.user ?? "";
    message.signatureData =
      object.signatureData?.map((e) => SignatureDatum.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgCreateRequestForFundsResponse(): MsgCreateRequestForFundsResponse {
  return { id: Long.UZERO };
}

export const MsgCreateRequestForFundsResponse: MessageFns<MsgCreateRequestForFundsResponse> =
  {
    encode(
      message: MsgCreateRequestForFundsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgCreateRequestForFundsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreateRequestForFundsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MsgCreateRequestForFundsResponse {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: MsgCreateRequestForFundsResponse): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreateRequestForFundsResponse>, I>>(
      base?: I,
    ): MsgCreateRequestForFundsResponse {
      return MsgCreateRequestForFundsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<MsgCreateRequestForFundsResponse>, I>,
    >(object: I): MsgCreateRequestForFundsResponse {
      const message = createBaseMsgCreateRequestForFundsResponse();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseQueryGetRequestForFundsRequest(): QueryGetRequestForFundsRequest {
  return { id: Long.UZERO };
}

export const QueryGetRequestForFundsRequest: MessageFns<QueryGetRequestForFundsRequest> =
  {
    encode(
      message: QueryGetRequestForFundsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetRequestForFundsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetRequestForFundsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetRequestForFundsRequest {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: QueryGetRequestForFundsRequest): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetRequestForFundsRequest>, I>>(
      base?: I,
    ): QueryGetRequestForFundsRequest {
      return QueryGetRequestForFundsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryGetRequestForFundsRequest>, I>,
    >(object: I): QueryGetRequestForFundsRequest {
      const message = createBaseQueryGetRequestForFundsRequest();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseQueryGetRequestForFundsResponse(): QueryGetRequestForFundsResponse {
  return { requestForFunds: undefined };
}

export const QueryGetRequestForFundsResponse: MessageFns<QueryGetRequestForFundsResponse> =
  {
    encode(
      message: QueryGetRequestForFundsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.requestForFunds !== undefined) {
        RequestForFunds.encode(
          message.requestForFunds,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetRequestForFundsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetRequestForFundsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.requestForFunds = RequestForFunds.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetRequestForFundsResponse {
      return {
        requestForFunds: isSet(object.requestForFunds)
          ? RequestForFunds.fromJSON(object.requestForFunds)
          : undefined,
      };
    },

    toJSON(message: QueryGetRequestForFundsResponse): unknown {
      const obj: any = {};
      if (message.requestForFunds !== undefined) {
        obj.requestForFunds = RequestForFunds.toJSON(message.requestForFunds);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetRequestForFundsResponse>, I>>(
      base?: I,
    ): QueryGetRequestForFundsResponse {
      return QueryGetRequestForFundsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryGetRequestForFundsResponse>, I>,
    >(object: I): QueryGetRequestForFundsResponse {
      const message = createBaseQueryGetRequestForFundsResponse();
      message.requestForFunds =
        object.requestForFunds !== undefined && object.requestForFunds !== null
          ? RequestForFunds.fromPartial(object.requestForFunds)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllRequestForFundsRequest(): QueryAllRequestForFundsRequest {
  return { pagination: undefined };
}

export const QueryAllRequestForFundsRequest: MessageFns<QueryAllRequestForFundsRequest> =
  {
    encode(
      message: QueryAllRequestForFundsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllRequestForFundsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllRequestForFundsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllRequestForFundsRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllRequestForFundsRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllRequestForFundsRequest>, I>>(
      base?: I,
    ): QueryAllRequestForFundsRequest {
      return QueryAllRequestForFundsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryAllRequestForFundsRequest>, I>,
    >(object: I): QueryAllRequestForFundsRequest {
      const message = createBaseQueryAllRequestForFundsRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllRequestForFundsResponse(): QueryAllRequestForFundsResponse {
  return { requestForFunds: [], pagination: undefined };
}

export const QueryAllRequestForFundsResponse: MessageFns<QueryAllRequestForFundsResponse> =
  {
    encode(
      message: QueryAllRequestForFundsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.requestForFunds) {
        RequestForFunds.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllRequestForFundsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllRequestForFundsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.requestForFunds.push(
              RequestForFunds.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllRequestForFundsResponse {
      return {
        requestForFunds: globalThis.Array.isArray(object?.requestForFunds)
          ? object.requestForFunds.map((e: any) => RequestForFunds.fromJSON(e))
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllRequestForFundsResponse): unknown {
      const obj: any = {};
      if (message.requestForFunds?.length) {
        obj.requestForFunds = message.requestForFunds.map((e) =>
          RequestForFunds.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllRequestForFundsResponse>, I>>(
      base?: I,
    ): QueryAllRequestForFundsResponse {
      return QueryAllRequestForFundsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryAllRequestForFundsResponse>, I>,
    >(object: I): QueryAllRequestForFundsResponse {
      const message = createBaseQueryAllRequestForFundsResponse();
      message.requestForFunds =
        object.requestForFunds?.map((e) => RequestForFunds.fromPartial(e)) ||
        [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseRouteFee(): RouteFee {
  return {
    sourceUniverse: 0,
    destinationUniverse: 0,
    sourceChainID: new Uint8Array(0),
    destinationChainID: new Uint8Array(0),
    sourceTokenAddress: new Uint8Array(0),
    destinationTokenAddress: new Uint8Array(0),
    feeBP: 0,
  };
}

export const RouteFee: MessageFns<RouteFee> = {
  encode(
    message: RouteFee,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceUniverse !== 0) {
      writer.uint32(8).int32(message.sourceUniverse);
    }
    if (message.destinationUniverse !== 0) {
      writer.uint32(16).int32(message.destinationUniverse);
    }
    if (message.sourceChainID.length !== 0) {
      writer.uint32(26).bytes(message.sourceChainID);
    }
    if (message.destinationChainID.length !== 0) {
      writer.uint32(34).bytes(message.destinationChainID);
    }
    if (message.sourceTokenAddress.length !== 0) {
      writer.uint32(42).bytes(message.sourceTokenAddress);
    }
    if (message.destinationTokenAddress.length !== 0) {
      writer.uint32(50).bytes(message.destinationTokenAddress);
    }
    if (message.feeBP !== 0) {
      writer.uint32(80).uint32(message.feeBP);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteFee {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sourceUniverse = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.destinationUniverse = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceChainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinationChainID = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sourceTokenAddress = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destinationTokenAddress = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.feeBP = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteFee {
    return {
      sourceUniverse: isSet(object.sourceUniverse)
        ? universeFromJSON(object.sourceUniverse)
        : 0,
      destinationUniverse: isSet(object.destinationUniverse)
        ? universeFromJSON(object.destinationUniverse)
        : 0,
      sourceChainID: isSet(object.sourceChainID)
        ? bytesFromBase64(object.sourceChainID)
        : new Uint8Array(0),
      destinationChainID: isSet(object.destinationChainID)
        ? bytesFromBase64(object.destinationChainID)
        : new Uint8Array(0),
      sourceTokenAddress: isSet(object.sourceTokenAddress)
        ? bytesFromBase64(object.sourceTokenAddress)
        : new Uint8Array(0),
      destinationTokenAddress: isSet(object.destinationTokenAddress)
        ? bytesFromBase64(object.destinationTokenAddress)
        : new Uint8Array(0),
      feeBP: isSet(object.feeBP) ? globalThis.Number(object.feeBP) : 0,
    };
  },

  toJSON(message: RouteFee): unknown {
    const obj: any = {};
    if (message.sourceUniverse !== 0) {
      obj.sourceUniverse = universeToJSON(message.sourceUniverse);
    }
    if (message.destinationUniverse !== 0) {
      obj.destinationUniverse = universeToJSON(message.destinationUniverse);
    }
    if (message.sourceChainID.length !== 0) {
      obj.sourceChainID = base64FromBytes(message.sourceChainID);
    }
    if (message.destinationChainID.length !== 0) {
      obj.destinationChainID = base64FromBytes(message.destinationChainID);
    }
    if (message.sourceTokenAddress.length !== 0) {
      obj.sourceTokenAddress = base64FromBytes(message.sourceTokenAddress);
    }
    if (message.destinationTokenAddress.length !== 0) {
      obj.destinationTokenAddress = base64FromBytes(
        message.destinationTokenAddress,
      );
    }
    if (message.feeBP !== 0) {
      obj.feeBP = Math.round(message.feeBP);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteFee>, I>>(base?: I): RouteFee {
    return RouteFee.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteFee>, I>>(object: I): RouteFee {
    const message = createBaseRouteFee();
    message.sourceUniverse = object.sourceUniverse ?? 0;
    message.destinationUniverse = object.destinationUniverse ?? 0;
    message.sourceChainID = object.sourceChainID ?? new Uint8Array(0);
    message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
    message.sourceTokenAddress = object.sourceTokenAddress ?? new Uint8Array(0);
    message.destinationTokenAddress =
      object.destinationTokenAddress ?? new Uint8Array(0);
    message.feeBP = object.feeBP ?? 0;
    return message;
  },
};

function createBaseSolverAddress(): SolverAddress {
  return {
    universe: 0,
    address: new Uint8Array(0),
    signature: new Uint8Array(0),
  };
}

export const SolverAddress: MessageFns<SolverAddress> = {
  encode(
    message: SolverAddress,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolverAddress {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolverAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolverAddress {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SolverAddress): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolverAddress>, I>>(
    base?: I,
  ): SolverAddress {
    return SolverAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolverAddress>, I>>(
    object: I,
  ): SolverAddress {
    const message = createBaseSolverAddress();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSolverData(): SolverData {
  return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}

export const SolverData: MessageFns<SolverData> = {
  encode(
    message: SolverData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cosmosAddress !== "") {
      writer.uint32(10).string(message.cosmosAddress);
    }
    for (const v of message.advertisedFees) {
      RouteFee.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.addresses) {
      SolverAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolverData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolverData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cosmosAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.advertisedFees.push(RouteFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(SolverAddress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolverData {
    return {
      cosmosAddress: isSet(object.cosmosAddress)
        ? globalThis.String(object.cosmosAddress)
        : "",
      advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
        ? object.advertisedFees.map((e: any) => RouteFee.fromJSON(e))
        : [],
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => SolverAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SolverData): unknown {
    const obj: any = {};
    if (message.cosmosAddress !== "") {
      obj.cosmosAddress = message.cosmosAddress;
    }
    if (message.advertisedFees?.length) {
      obj.advertisedFees = message.advertisedFees.map((e) =>
        RouteFee.toJSON(e),
      );
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => SolverAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolverData>, I>>(base?: I): SolverData {
    return SolverData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolverData>, I>>(
    object: I,
  ): SolverData {
    const message = createBaseSolverData();
    message.cosmosAddress = object.cosmosAddress ?? "";
    message.advertisedFees =
      object.advertisedFees?.map((e) => RouteFee.fromPartial(e)) || [];
    message.addresses =
      object.addresses?.map((e) => SolverAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryGetSolverDataRequest(): QueryGetSolverDataRequest {
  return { cosmosAddress: "" };
}

export const QueryGetSolverDataRequest: MessageFns<QueryGetSolverDataRequest> =
  {
    encode(
      message: QueryGetSolverDataRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.cosmosAddress !== "") {
        writer.uint32(10).string(message.cosmosAddress);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetSolverDataRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetSolverDataRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.cosmosAddress = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetSolverDataRequest {
      return {
        cosmosAddress: isSet(object.cosmosAddress)
          ? globalThis.String(object.cosmosAddress)
          : "",
      };
    },

    toJSON(message: QueryGetSolverDataRequest): unknown {
      const obj: any = {};
      if (message.cosmosAddress !== "") {
        obj.cosmosAddress = message.cosmosAddress;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetSolverDataRequest>, I>>(
      base?: I,
    ): QueryGetSolverDataRequest {
      return QueryGetSolverDataRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetSolverDataRequest>, I>>(
      object: I,
    ): QueryGetSolverDataRequest {
      const message = createBaseQueryGetSolverDataRequest();
      message.cosmosAddress = object.cosmosAddress ?? "";
      return message;
    },
  };

function createBaseQueryGetSolverDataResponse(): QueryGetSolverDataResponse {
  return { solverData: undefined };
}

export const QueryGetSolverDataResponse: MessageFns<QueryGetSolverDataResponse> =
  {
    encode(
      message: QueryGetSolverDataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.solverData !== undefined) {
        SolverData.encode(message.solverData, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetSolverDataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetSolverDataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.solverData = SolverData.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetSolverDataResponse {
      return {
        solverData: isSet(object.solverData)
          ? SolverData.fromJSON(object.solverData)
          : undefined,
      };
    },

    toJSON(message: QueryGetSolverDataResponse): unknown {
      const obj: any = {};
      if (message.solverData !== undefined) {
        obj.solverData = SolverData.toJSON(message.solverData);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetSolverDataResponse>, I>>(
      base?: I,
    ): QueryGetSolverDataResponse {
      return QueryGetSolverDataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetSolverDataResponse>, I>>(
      object: I,
    ): QueryGetSolverDataResponse {
      const message = createBaseQueryGetSolverDataResponse();
      message.solverData =
        object.solverData !== undefined && object.solverData !== null
          ? SolverData.fromPartial(object.solverData)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllSolverDataRequest(): QueryAllSolverDataRequest {
  return { pagination: undefined };
}

export const QueryAllSolverDataRequest: MessageFns<QueryAllSolverDataRequest> =
  {
    encode(
      message: QueryAllSolverDataRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllSolverDataRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllSolverDataRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllSolverDataRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllSolverDataRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllSolverDataRequest>, I>>(
      base?: I,
    ): QueryAllSolverDataRequest {
      return QueryAllSolverDataRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllSolverDataRequest>, I>>(
      object: I,
    ): QueryAllSolverDataRequest {
      const message = createBaseQueryAllSolverDataRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllSolverDataResponse(): QueryAllSolverDataResponse {
  return { solverData: [], pagination: undefined };
}

export const QueryAllSolverDataResponse: MessageFns<QueryAllSolverDataResponse> =
  {
    encode(
      message: QueryAllSolverDataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.solverData) {
        SolverData.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllSolverDataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllSolverDataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.solverData.push(SolverData.decode(reader, reader.uint32()));
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllSolverDataResponse {
      return {
        solverData: globalThis.Array.isArray(object?.solverData)
          ? object.solverData.map((e: any) => SolverData.fromJSON(e))
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllSolverDataResponse): unknown {
      const obj: any = {};
      if (message.solverData?.length) {
        obj.solverData = message.solverData.map((e) => SolverData.toJSON(e));
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllSolverDataResponse>, I>>(
      base?: I,
    ): QueryAllSolverDataResponse {
      return QueryAllSolverDataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllSolverDataResponse>, I>>(
      object: I,
    ): QueryAllSolverDataResponse {
      const message = createBaseQueryAllSolverDataResponse();
      message.solverData =
        object.solverData?.map((e) => SolverData.fromPartial(e)) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseMsgCreateSolverData(): MsgCreateSolverData {
  return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}

export const MsgCreateSolverData: MessageFns<MsgCreateSolverData> = {
  encode(
    message: MsgCreateSolverData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cosmosAddress !== "") {
      writer.uint32(10).string(message.cosmosAddress);
    }
    for (const v of message.advertisedFees) {
      RouteFee.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.addresses) {
      SolverAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgCreateSolverData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateSolverData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cosmosAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.advertisedFees.push(RouteFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(SolverAddress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateSolverData {
    return {
      cosmosAddress: isSet(object.cosmosAddress)
        ? globalThis.String(object.cosmosAddress)
        : "",
      advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
        ? object.advertisedFees.map((e: any) => RouteFee.fromJSON(e))
        : [],
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => SolverAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgCreateSolverData): unknown {
    const obj: any = {};
    if (message.cosmosAddress !== "") {
      obj.cosmosAddress = message.cosmosAddress;
    }
    if (message.advertisedFees?.length) {
      obj.advertisedFees = message.advertisedFees.map((e) =>
        RouteFee.toJSON(e),
      );
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => SolverAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateSolverData>, I>>(
    base?: I,
  ): MsgCreateSolverData {
    return MsgCreateSolverData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateSolverData>, I>>(
    object: I,
  ): MsgCreateSolverData {
    const message = createBaseMsgCreateSolverData();
    message.cosmosAddress = object.cosmosAddress ?? "";
    message.advertisedFees =
      object.advertisedFees?.map((e) => RouteFee.fromPartial(e)) || [];
    message.addresses =
      object.addresses?.map((e) => SolverAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgCreateSolverDataResponse(): MsgCreateSolverDataResponse {
  return {};
}

export const MsgCreateSolverDataResponse: MessageFns<MsgCreateSolverDataResponse> =
  {
    encode(
      _: MsgCreateSolverDataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgCreateSolverDataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreateSolverDataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgCreateSolverDataResponse {
      return {};
    },

    toJSON(_: MsgCreateSolverDataResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreateSolverDataResponse>, I>>(
      base?: I,
    ): MsgCreateSolverDataResponse {
      return MsgCreateSolverDataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgCreateSolverDataResponse>, I>>(
      _: I,
    ): MsgCreateSolverDataResponse {
      const message = createBaseMsgCreateSolverDataResponse();
      return message;
    },
  };

function createBaseMsgUpdateSolverData(): MsgUpdateSolverData {
  return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}

export const MsgUpdateSolverData: MessageFns<MsgUpdateSolverData> = {
  encode(
    message: MsgUpdateSolverData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cosmosAddress !== "") {
      writer.uint32(10).string(message.cosmosAddress);
    }
    for (const v of message.advertisedFees) {
      RouteFee.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.addresses) {
      SolverAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgUpdateSolverData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSolverData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cosmosAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.advertisedFees.push(RouteFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(SolverAddress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateSolverData {
    return {
      cosmosAddress: isSet(object.cosmosAddress)
        ? globalThis.String(object.cosmosAddress)
        : "",
      advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
        ? object.advertisedFees.map((e: any) => RouteFee.fromJSON(e))
        : [],
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => SolverAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateSolverData): unknown {
    const obj: any = {};
    if (message.cosmosAddress !== "") {
      obj.cosmosAddress = message.cosmosAddress;
    }
    if (message.advertisedFees?.length) {
      obj.advertisedFees = message.advertisedFees.map((e) =>
        RouteFee.toJSON(e),
      );
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => SolverAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateSolverData>, I>>(
    base?: I,
  ): MsgUpdateSolverData {
    return MsgUpdateSolverData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateSolverData>, I>>(
    object: I,
  ): MsgUpdateSolverData {
    const message = createBaseMsgUpdateSolverData();
    message.cosmosAddress = object.cosmosAddress ?? "";
    message.advertisedFees =
      object.advertisedFees?.map((e) => RouteFee.fromPartial(e)) || [];
    message.addresses =
      object.addresses?.map((e) => SolverAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpdateSolverDataResponse(): MsgUpdateSolverDataResponse {
  return {};
}

export const MsgUpdateSolverDataResponse: MessageFns<MsgUpdateSolverDataResponse> =
  {
    encode(
      _: MsgUpdateSolverDataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgUpdateSolverDataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgUpdateSolverDataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgUpdateSolverDataResponse {
      return {};
    },

    toJSON(_: MsgUpdateSolverDataResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgUpdateSolverDataResponse>, I>>(
      base?: I,
    ): MsgUpdateSolverDataResponse {
      return MsgUpdateSolverDataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgUpdateSolverDataResponse>, I>>(
      _: I,
    ): MsgUpdateSolverDataResponse {
      const message = createBaseMsgUpdateSolverDataResponse();
      return message;
    },
  };

function createBaseSettlement(): Settlement {
  return {
    id: new Uint8Array(0),
    universe: 0,
    chainId: new Uint8Array(0),
    amounts: [],
    tokenAddress: [],
    filler: [],
    success: false,
  };
}

export const Settlement: MessageFns<Settlement> = {
  encode(
    message: Settlement,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.universe !== 0) {
      writer.uint32(16).int32(message.universe);
    }
    if (message.chainId.length !== 0) {
      writer.uint32(26).bytes(message.chainId);
    }
    for (const v of message.amounts) {
      writer.uint32(34).bytes(v!);
    }
    for (const v of message.tokenAddress) {
      writer.uint32(42).bytes(v!);
    }
    for (const v of message.filler) {
      writer.uint32(50).bytes(v!);
    }
    if (message.success !== false) {
      writer.uint32(56).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settlement {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettlement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amounts.push(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenAddress.push(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.filler.push(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settlement {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainId: isSet(object.chainId)
        ? bytesFromBase64(object.chainId)
        : new Uint8Array(0),
      amounts: globalThis.Array.isArray(object?.amounts)
        ? object.amounts.map((e: any) => bytesFromBase64(e))
        : [],
      tokenAddress: globalThis.Array.isArray(object?.tokenAddress)
        ? object.tokenAddress.map((e: any) => bytesFromBase64(e))
        : [],
      filler: globalThis.Array.isArray(object?.filler)
        ? object.filler.map((e: any) => bytesFromBase64(e))
        : [],
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
    };
  },

  toJSON(message: Settlement): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainId.length !== 0) {
      obj.chainId = base64FromBytes(message.chainId);
    }
    if (message.amounts?.length) {
      obj.amounts = message.amounts.map((e) => base64FromBytes(e));
    }
    if (message.tokenAddress?.length) {
      obj.tokenAddress = message.tokenAddress.map((e) => base64FromBytes(e));
    }
    if (message.filler?.length) {
      obj.filler = message.filler.map((e) => base64FromBytes(e));
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Settlement>, I>>(base?: I): Settlement {
    return Settlement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Settlement>, I>>(
    object: I,
  ): Settlement {
    const message = createBaseSettlement();
    message.id = object.id ?? new Uint8Array(0);
    message.universe = object.universe ?? 0;
    message.chainId = object.chainId ?? new Uint8Array(0);
    message.amounts = object.amounts?.map((e) => e) || [];
    message.tokenAddress = object.tokenAddress?.map((e) => e) || [];
    message.filler = object.filler?.map((e) => e) || [];
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseQueryGetSettlementRequest(): QueryGetSettlementRequest {
  return { id: Long.UZERO };
}

export const QueryGetSettlementRequest: MessageFns<QueryGetSettlementRequest> =
  {
    encode(
      message: QueryGetSettlementRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetSettlementRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetSettlementRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetSettlementRequest {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: QueryGetSettlementRequest): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetSettlementRequest>, I>>(
      base?: I,
    ): QueryGetSettlementRequest {
      return QueryGetSettlementRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetSettlementRequest>, I>>(
      object: I,
    ): QueryGetSettlementRequest {
      const message = createBaseQueryGetSettlementRequest();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseQueryGetSettlementResponse(): QueryGetSettlementResponse {
  return { Settlement: undefined };
}

export const QueryGetSettlementResponse: MessageFns<QueryGetSettlementResponse> =
  {
    encode(
      message: QueryGetSettlementResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.Settlement !== undefined) {
        Settlement.encode(message.Settlement, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetSettlementResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetSettlementResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.Settlement = Settlement.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetSettlementResponse {
      return {
        Settlement: isSet(object.Settlement)
          ? Settlement.fromJSON(object.Settlement)
          : undefined,
      };
    },

    toJSON(message: QueryGetSettlementResponse): unknown {
      const obj: any = {};
      if (message.Settlement !== undefined) {
        obj.Settlement = Settlement.toJSON(message.Settlement);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetSettlementResponse>, I>>(
      base?: I,
    ): QueryGetSettlementResponse {
      return QueryGetSettlementResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetSettlementResponse>, I>>(
      object: I,
    ): QueryGetSettlementResponse {
      const message = createBaseQueryGetSettlementResponse();
      message.Settlement =
        object.Settlement !== undefined && object.Settlement !== null
          ? Settlement.fromPartial(object.Settlement)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllSettlementRequest(): QueryAllSettlementRequest {
  return { pagination: undefined };
}

export const QueryAllSettlementRequest: MessageFns<QueryAllSettlementRequest> =
  {
    encode(
      message: QueryAllSettlementRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllSettlementRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllSettlementRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllSettlementRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllSettlementRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllSettlementRequest>, I>>(
      base?: I,
    ): QueryAllSettlementRequest {
      return QueryAllSettlementRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllSettlementRequest>, I>>(
      object: I,
    ): QueryAllSettlementRequest {
      const message = createBaseQueryAllSettlementRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllSettlementResponse(): QueryAllSettlementResponse {
  return { Settlement: [], pagination: undefined };
}

export const QueryAllSettlementResponse: MessageFns<QueryAllSettlementResponse> =
  {
    encode(
      message: QueryAllSettlementResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.Settlement) {
        Settlement.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllSettlementResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllSettlementResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.Settlement.push(Settlement.decode(reader, reader.uint32()));
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllSettlementResponse {
      return {
        Settlement: globalThis.Array.isArray(object?.Settlement)
          ? object.Settlement.map((e: any) => Settlement.fromJSON(e))
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllSettlementResponse): unknown {
      const obj: any = {};
      if (message.Settlement?.length) {
        obj.Settlement = message.Settlement.map((e) => Settlement.toJSON(e));
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllSettlementResponse>, I>>(
      base?: I,
    ): QueryAllSettlementResponse {
      return QueryAllSettlementResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllSettlementResponse>, I>>(
      object: I,
    ): QueryAllSettlementResponse {
      const message = createBaseQueryAllSettlementResponse();
      message.Settlement =
        object.Settlement?.map((e) => Settlement.fromPartial(e)) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseFixedFeeTuple(): FixedFeeTuple {
  return {
    universe: 0,
    chainID: new Uint8Array(0),
    tokenAddress: new Uint8Array(0),
    fee: new Uint8Array(0),
  };
}

export const FixedFeeTuple: MessageFns<FixedFeeTuple> = {
  encode(
    message: FixedFeeTuple,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(18).bytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      writer.uint32(26).bytes(message.tokenAddress);
    }
    if (message.fee.length !== 0) {
      writer.uint32(34).bytes(message.fee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixedFeeTuple {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixedFeeTuple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fee = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixedFeeTuple {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      tokenAddress: isSet(object.tokenAddress)
        ? bytesFromBase64(object.tokenAddress)
        : new Uint8Array(0),
      fee: isSet(object.fee) ? bytesFromBase64(object.fee) : new Uint8Array(0),
    };
  },

  toJSON(message: FixedFeeTuple): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    if (message.fee.length !== 0) {
      obj.fee = base64FromBytes(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FixedFeeTuple>, I>>(
    base?: I,
  ): FixedFeeTuple {
    return FixedFeeTuple.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FixedFeeTuple>, I>>(
    object: I,
  ): FixedFeeTuple {
    const message = createBaseFixedFeeTuple();
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
    message.fee = object.fee ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAdminFeeRecipient(): AdminFeeRecipient {
  return { universe: 0, address: new Uint8Array(0) };
}

export const AdminFeeRecipient: MessageFns<AdminFeeRecipient> = {
  encode(
    message: AdminFeeRecipient,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminFeeRecipient {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminFeeRecipient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminFeeRecipient {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
    };
  },

  toJSON(message: AdminFeeRecipient): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminFeeRecipient>, I>>(
    base?: I,
  ): AdminFeeRecipient {
    return AdminFeeRecipient.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminFeeRecipient>, I>>(
    object: I,
  ): AdminFeeRecipient {
    const message = createBaseAdminFeeRecipient();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProtocolFees(): ProtocolFees {
  return {
    feeBP: Long.UZERO,
    collectionFees: [],
    fulfilmentFees: [],
    admin: "",
    feeRecipients: [],
  };
}

export const ProtocolFees: MessageFns<ProtocolFees> = {
  encode(
    message: ProtocolFees,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.feeBP.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.feeBP.toString());
    }
    for (const v of message.collectionFees) {
      FixedFeeTuple.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.fulfilmentFees) {
      FixedFeeTuple.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.admin !== "") {
      writer.uint32(34).string(message.admin);
    }
    for (const v of message.feeRecipients) {
      AdminFeeRecipient.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtocolFees {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocolFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.feeBP = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collectionFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fulfilmentFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feeRecipients.push(
            AdminFeeRecipient.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtocolFees {
    return {
      feeBP: isSet(object.feeBP) ? Long.fromValue(object.feeBP) : Long.UZERO,
      collectionFees: globalThis.Array.isArray(object?.collectionFees)
        ? object.collectionFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
        ? object.fulfilmentFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
        ? object.feeRecipients.map((e: any) => AdminFeeRecipient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProtocolFees): unknown {
    const obj: any = {};
    if (!message.feeBP.equals(Long.UZERO)) {
      obj.feeBP = (message.feeBP || Long.UZERO).toString();
    }
    if (message.collectionFees?.length) {
      obj.collectionFees = message.collectionFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.fulfilmentFees?.length) {
      obj.fulfilmentFees = message.fulfilmentFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.feeRecipients?.length) {
      obj.feeRecipients = message.feeRecipients.map((e) =>
        AdminFeeRecipient.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtocolFees>, I>>(
    base?: I,
  ): ProtocolFees {
    return ProtocolFees.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtocolFees>, I>>(
    object: I,
  ): ProtocolFees {
    const message = createBaseProtocolFees();
    message.feeBP =
      object.feeBP !== undefined && object.feeBP !== null
        ? Long.fromValue(object.feeBP)
        : Long.UZERO;
    message.collectionFees =
      object.collectionFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.fulfilmentFees =
      object.fulfilmentFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.admin = object.admin ?? "";
    message.feeRecipients =
      object.feeRecipients?.map((e) => AdminFeeRecipient.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryGetProtocolFeesRequest(): QueryGetProtocolFeesRequest {
  return {};
}

export const QueryGetProtocolFeesRequest: MessageFns<QueryGetProtocolFeesRequest> =
  {
    encode(
      _: QueryGetProtocolFeesRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetProtocolFeesRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetProtocolFeesRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): QueryGetProtocolFeesRequest {
      return {};
    },

    toJSON(_: QueryGetProtocolFeesRequest): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetProtocolFeesRequest>, I>>(
      base?: I,
    ): QueryGetProtocolFeesRequest {
      return QueryGetProtocolFeesRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetProtocolFeesRequest>, I>>(
      _: I,
    ): QueryGetProtocolFeesRequest {
      const message = createBaseQueryGetProtocolFeesRequest();
      return message;
    },
  };

function createBaseQueryGetProtocolFeesResponse(): QueryGetProtocolFeesResponse {
  return { ProtocolFees: undefined };
}

export const QueryGetProtocolFeesResponse: MessageFns<QueryGetProtocolFeesResponse> =
  {
    encode(
      message: QueryGetProtocolFeesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.ProtocolFees !== undefined) {
        ProtocolFees.encode(
          message.ProtocolFees,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetProtocolFeesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetProtocolFeesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.ProtocolFees = ProtocolFees.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetProtocolFeesResponse {
      return {
        ProtocolFees: isSet(object.ProtocolFees)
          ? ProtocolFees.fromJSON(object.ProtocolFees)
          : undefined,
      };
    },

    toJSON(message: QueryGetProtocolFeesResponse): unknown {
      const obj: any = {};
      if (message.ProtocolFees !== undefined) {
        obj.ProtocolFees = ProtocolFees.toJSON(message.ProtocolFees);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetProtocolFeesResponse>, I>>(
      base?: I,
    ): QueryGetProtocolFeesResponse {
      return QueryGetProtocolFeesResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetProtocolFeesResponse>, I>>(
      object: I,
    ): QueryGetProtocolFeesResponse {
      const message = createBaseQueryGetProtocolFeesResponse();
      message.ProtocolFees =
        object.ProtocolFees !== undefined && object.ProtocolFees !== null
          ? ProtocolFees.fromPartial(object.ProtocolFees)
          : undefined;
      return message;
    },
  };

function createBaseMsgCreateProtocolFees(): MsgCreateProtocolFees {
  return {
    creator: "",
    feeBP: Long.UZERO,
    collectionFees: [],
    fulfilmentFees: [],
    feeRecipients: [],
  };
}

export const MsgCreateProtocolFees: MessageFns<MsgCreateProtocolFees> = {
  encode(
    message: MsgCreateProtocolFees,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (!message.feeBP.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feeBP.toString());
    }
    for (const v of message.collectionFees) {
      FixedFeeTuple.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.fulfilmentFees) {
      FixedFeeTuple.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.feeRecipients) {
      AdminFeeRecipient.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgCreateProtocolFees {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateProtocolFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feeBP = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collectionFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fulfilmentFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feeRecipients.push(
            AdminFeeRecipient.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateProtocolFees {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      feeBP: isSet(object.feeBP) ? Long.fromValue(object.feeBP) : Long.UZERO,
      collectionFees: globalThis.Array.isArray(object?.collectionFees)
        ? object.collectionFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
        ? object.fulfilmentFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
        ? object.feeRecipients.map((e: any) => AdminFeeRecipient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgCreateProtocolFees): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (!message.feeBP.equals(Long.UZERO)) {
      obj.feeBP = (message.feeBP || Long.UZERO).toString();
    }
    if (message.collectionFees?.length) {
      obj.collectionFees = message.collectionFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.fulfilmentFees?.length) {
      obj.fulfilmentFees = message.fulfilmentFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.feeRecipients?.length) {
      obj.feeRecipients = message.feeRecipients.map((e) =>
        AdminFeeRecipient.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateProtocolFees>, I>>(
    base?: I,
  ): MsgCreateProtocolFees {
    return MsgCreateProtocolFees.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateProtocolFees>, I>>(
    object: I,
  ): MsgCreateProtocolFees {
    const message = createBaseMsgCreateProtocolFees();
    message.creator = object.creator ?? "";
    message.feeBP =
      object.feeBP !== undefined && object.feeBP !== null
        ? Long.fromValue(object.feeBP)
        : Long.UZERO;
    message.collectionFees =
      object.collectionFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.fulfilmentFees =
      object.fulfilmentFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.feeRecipients =
      object.feeRecipients?.map((e) => AdminFeeRecipient.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgCreateProtocolFeesResponse(): MsgCreateProtocolFeesResponse {
  return {};
}

export const MsgCreateProtocolFeesResponse: MessageFns<MsgCreateProtocolFeesResponse> =
  {
    encode(
      _: MsgCreateProtocolFeesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgCreateProtocolFeesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreateProtocolFeesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgCreateProtocolFeesResponse {
      return {};
    },

    toJSON(_: MsgCreateProtocolFeesResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreateProtocolFeesResponse>, I>>(
      base?: I,
    ): MsgCreateProtocolFeesResponse {
      return MsgCreateProtocolFeesResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgCreateProtocolFeesResponse>, I>>(
      _: I,
    ): MsgCreateProtocolFeesResponse {
      const message = createBaseMsgCreateProtocolFeesResponse();
      return message;
    },
  };

function createBaseMsgUpdateProtocolFees(): MsgUpdateProtocolFees {
  return {
    creator: "",
    feeBP: Long.UZERO,
    collectionFees: [],
    fulfilmentFees: [],
    feeRecipients: [],
  };
}

export const MsgUpdateProtocolFees: MessageFns<MsgUpdateProtocolFees> = {
  encode(
    message: MsgUpdateProtocolFees,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (!message.feeBP.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feeBP.toString());
    }
    for (const v of message.collectionFees) {
      FixedFeeTuple.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.fulfilmentFees) {
      FixedFeeTuple.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.feeRecipients) {
      AdminFeeRecipient.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgUpdateProtocolFees {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateProtocolFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feeBP = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collectionFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fulfilmentFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feeRecipients.push(
            AdminFeeRecipient.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateProtocolFees {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      feeBP: isSet(object.feeBP) ? Long.fromValue(object.feeBP) : Long.UZERO,
      collectionFees: globalThis.Array.isArray(object?.collectionFees)
        ? object.collectionFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
        ? object.fulfilmentFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
        ? object.feeRecipients.map((e: any) => AdminFeeRecipient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateProtocolFees): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (!message.feeBP.equals(Long.UZERO)) {
      obj.feeBP = (message.feeBP || Long.UZERO).toString();
    }
    if (message.collectionFees?.length) {
      obj.collectionFees = message.collectionFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.fulfilmentFees?.length) {
      obj.fulfilmentFees = message.fulfilmentFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.feeRecipients?.length) {
      obj.feeRecipients = message.feeRecipients.map((e) =>
        AdminFeeRecipient.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateProtocolFees>, I>>(
    base?: I,
  ): MsgUpdateProtocolFees {
    return MsgUpdateProtocolFees.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateProtocolFees>, I>>(
    object: I,
  ): MsgUpdateProtocolFees {
    const message = createBaseMsgUpdateProtocolFees();
    message.creator = object.creator ?? "";
    message.feeBP =
      object.feeBP !== undefined && object.feeBP !== null
        ? Long.fromValue(object.feeBP)
        : Long.UZERO;
    message.collectionFees =
      object.collectionFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.fulfilmentFees =
      object.fulfilmentFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.feeRecipients =
      object.feeRecipients?.map((e) => AdminFeeRecipient.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpdateProtocolFeesResponse(): MsgUpdateProtocolFeesResponse {
  return {};
}

export const MsgUpdateProtocolFeesResponse: MessageFns<MsgUpdateProtocolFeesResponse> =
  {
    encode(
      _: MsgUpdateProtocolFeesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgUpdateProtocolFeesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgUpdateProtocolFeesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgUpdateProtocolFeesResponse {
      return {};
    },

    toJSON(_: MsgUpdateProtocolFeesResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgUpdateProtocolFeesResponse>, I>>(
      base?: I,
    ): MsgUpdateProtocolFeesResponse {
      return MsgUpdateProtocolFeesResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgUpdateProtocolFeesResponse>, I>>(
      _: I,
    ): MsgUpdateProtocolFeesResponse {
      const message = createBaseMsgUpdateProtocolFeesResponse();
      return message;
    },
  };

function createBasePriceOracleDatum(): PriceOracleDatum {
  return {
    universe: 0,
    chainID: new Uint8Array(0),
    tokenAddress: new Uint8Array(0),
    price: new Uint8Array(0),
    decimals: 0,
  };
}

export const PriceOracleDatum: MessageFns<PriceOracleDatum> = {
  encode(
    message: PriceOracleDatum,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(18).bytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      writer.uint32(26).bytes(message.tokenAddress);
    }
    if (message.price.length !== 0) {
      writer.uint32(34).bytes(message.price);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).uint32(message.decimals);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceOracleDatum {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceOracleDatum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.price = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceOracleDatum {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      tokenAddress: isSet(object.tokenAddress)
        ? bytesFromBase64(object.tokenAddress)
        : new Uint8Array(0),
      price: isSet(object.price)
        ? bytesFromBase64(object.price)
        : new Uint8Array(0),
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
    };
  },

  toJSON(message: PriceOracleDatum): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    if (message.price.length !== 0) {
      obj.price = base64FromBytes(message.price);
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PriceOracleDatum>, I>>(
    base?: I,
  ): PriceOracleDatum {
    return PriceOracleDatum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PriceOracleDatum>, I>>(
    object: I,
  ): PriceOracleDatum {
    const message = createBasePriceOracleDatum();
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
    message.price = object.price ?? new Uint8Array(0);
    message.decimals = object.decimals ?? 0;
    return message;
  },
};

function createBasePriceOracleData(): PriceOracleData {
  return { priceData: [] };
}

export const PriceOracleData: MessageFns<PriceOracleData> = {
  encode(
    message: PriceOracleData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.priceData) {
      PriceOracleDatum.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceOracleData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceOracleData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.priceData.push(
            PriceOracleDatum.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceOracleData {
    return {
      priceData: globalThis.Array.isArray(object?.priceData)
        ? object.priceData.map((e: any) => PriceOracleDatum.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PriceOracleData): unknown {
    const obj: any = {};
    if (message.priceData?.length) {
      obj.priceData = message.priceData.map((e) => PriceOracleDatum.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PriceOracleData>, I>>(
    base?: I,
  ): PriceOracleData {
    return PriceOracleData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PriceOracleData>, I>>(
    object: I,
  ): PriceOracleData {
    const message = createBasePriceOracleData();
    message.priceData =
      object.priceData?.map((e) => PriceOracleDatum.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryGetPriceOracleDataRequest(): QueryGetPriceOracleDataRequest {
  return {};
}

export const QueryGetPriceOracleDataRequest: MessageFns<QueryGetPriceOracleDataRequest> =
  {
    encode(
      _: QueryGetPriceOracleDataRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetPriceOracleDataRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetPriceOracleDataRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): QueryGetPriceOracleDataRequest {
      return {};
    },

    toJSON(_: QueryGetPriceOracleDataRequest): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetPriceOracleDataRequest>, I>>(
      base?: I,
    ): QueryGetPriceOracleDataRequest {
      return QueryGetPriceOracleDataRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryGetPriceOracleDataRequest>, I>,
    >(_: I): QueryGetPriceOracleDataRequest {
      const message = createBaseQueryGetPriceOracleDataRequest();
      return message;
    },
  };

function createBaseQueryGetPriceOracleDataResponse(): QueryGetPriceOracleDataResponse {
  return { PriceOracleData: undefined };
}

export const QueryGetPriceOracleDataResponse: MessageFns<QueryGetPriceOracleDataResponse> =
  {
    encode(
      message: QueryGetPriceOracleDataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.PriceOracleData !== undefined) {
        PriceOracleData.encode(
          message.PriceOracleData,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetPriceOracleDataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetPriceOracleDataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.PriceOracleData = PriceOracleData.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetPriceOracleDataResponse {
      return {
        PriceOracleData: isSet(object.PriceOracleData)
          ? PriceOracleData.fromJSON(object.PriceOracleData)
          : undefined,
      };
    },

    toJSON(message: QueryGetPriceOracleDataResponse): unknown {
      const obj: any = {};
      if (message.PriceOracleData !== undefined) {
        obj.PriceOracleData = PriceOracleData.toJSON(message.PriceOracleData);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetPriceOracleDataResponse>, I>>(
      base?: I,
    ): QueryGetPriceOracleDataResponse {
      return QueryGetPriceOracleDataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryGetPriceOracleDataResponse>, I>,
    >(object: I): QueryGetPriceOracleDataResponse {
      const message = createBaseQueryGetPriceOracleDataResponse();
      message.PriceOracleData =
        object.PriceOracleData !== undefined && object.PriceOracleData !== null
          ? PriceOracleData.fromPartial(object.PriceOracleData)
          : undefined;
      return message;
    },
  };

function createBaseMsgRefundReq(): MsgRefundReq {
  return { creator: "", rffID: Long.UZERO };
}

export const MsgRefundReq: MessageFns<MsgRefundReq> = {
  encode(
    message: MsgRefundReq,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (!message.rffID.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.rffID.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRefundReq {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRefundReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rffID = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRefundReq {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      rffID: isSet(object.rffID) ? Long.fromValue(object.rffID) : Long.UZERO,
    };
  },

  toJSON(message: MsgRefundReq): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (!message.rffID.equals(Long.UZERO)) {
      obj.rffID = (message.rffID || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRefundReq>, I>>(
    base?: I,
  ): MsgRefundReq {
    return MsgRefundReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRefundReq>, I>>(
    object: I,
  ): MsgRefundReq {
    const message = createBaseMsgRefundReq();
    message.creator = object.creator ?? "";
    message.rffID =
      object.rffID !== undefined && object.rffID !== null
        ? Long.fromValue(object.rffID)
        : Long.UZERO;
    return message;
  },
};

function createBaseMsgRefundReqResponse(): MsgRefundReqResponse {
  return {};
}

export const MsgRefundReqResponse: MessageFns<MsgRefundReqResponse> = {
  encode(
    _: MsgRefundReqResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgRefundReqResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRefundReqResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRefundReqResponse {
    return {};
  },

  toJSON(_: MsgRefundReqResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRefundReqResponse>, I>>(
    base?: I,
  ): MsgRefundReqResponse {
    return MsgRefundReqResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRefundReqResponse>, I>>(
    _: I,
  ): MsgRefundReqResponse {
    const message = createBaseMsgRefundReqResponse();
    return message;
  },
};

function createBaseDepositVEPacket(): DepositVEPacket {
  return { id: Long.UZERO, gasRefunded: false };
}

export const DepositVEPacket: MessageFns<DepositVEPacket> = {
  encode(
    message: DepositVEPacket,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    if (message.gasRefunded !== false) {
      writer.uint32(16).bool(message.gasRefunded);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositVEPacket {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositVEPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gasRefunded = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositVEPacket {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      gasRefunded: isSet(object.gasRefunded)
        ? globalThis.Boolean(object.gasRefunded)
        : false,
    };
  },

  toJSON(message: DepositVEPacket): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.gasRefunded !== false) {
      obj.gasRefunded = message.gasRefunded;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepositVEPacket>, I>>(
    base?: I,
  ): DepositVEPacket {
    return DepositVEPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepositVEPacket>, I>>(
    object: I,
  ): DepositVEPacket {
    const message = createBaseDepositVEPacket();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.gasRefunded = object.gasRefunded ?? false;
    return message;
  },
};

function createBaseFillVEPacket(): FillVEPacket {
  return {
    id: Long.UZERO,
    fillerAddress: new Uint8Array(0),
    transactionHash: new Uint8Array(0),
  };
}

export const FillVEPacket: MessageFns<FillVEPacket> = {
  encode(
    message: FillVEPacket,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    if (message.fillerAddress.length !== 0) {
      writer.uint32(18).bytes(message.fillerAddress);
    }
    if (message.transactionHash.length !== 0) {
      writer.uint32(26).bytes(message.transactionHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FillVEPacket {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFillVEPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fillerAddress = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactionHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FillVEPacket {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      fillerAddress: isSet(object.fillerAddress)
        ? bytesFromBase64(object.fillerAddress)
        : new Uint8Array(0),
      transactionHash: isSet(object.transactionHash)
        ? bytesFromBase64(object.transactionHash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: FillVEPacket): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.fillerAddress.length !== 0) {
      obj.fillerAddress = base64FromBytes(message.fillerAddress);
    }
    if (message.transactionHash.length !== 0) {
      obj.transactionHash = base64FromBytes(message.transactionHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FillVEPacket>, I>>(
    base?: I,
  ): FillVEPacket {
    return FillVEPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FillVEPacket>, I>>(
    object: I,
  ): FillVEPacket {
    const message = createBaseFillVEPacket();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.fillerAddress = object.fillerAddress ?? new Uint8Array(0);
    message.transactionHash = object.transactionHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgDoubleCheckTx(): MsgDoubleCheckTx {
  return {
    creator: "",
    txUniverse: 0,
    txChainID: new Uint8Array(0),
    packet: undefined,
  };
}

export const MsgDoubleCheckTx: MessageFns<MsgDoubleCheckTx> = {
  encode(
    message: MsgDoubleCheckTx,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.txUniverse !== 0) {
      writer.uint32(16).int32(message.txUniverse);
    }
    if (message.txChainID.length !== 0) {
      writer.uint32(26).bytes(message.txChainID);
    }
    switch (message.packet?.$case) {
      case "depositPacket":
        DepositVEPacket.encode(
          message.packet.value,
          writer.uint32(42).fork(),
        ).join();
        break;
      case "fillPacket":
        FillVEPacket.encode(
          message.packet.value,
          writer.uint32(50).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDoubleCheckTx {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDoubleCheckTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.txUniverse = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txChainID = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.packet = {
            $case: "depositPacket",
            value: DepositVEPacket.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.packet = {
            $case: "fillPacket",
            value: FillVEPacket.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDoubleCheckTx {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      txUniverse: isSet(object.txUniverse)
        ? universeFromJSON(object.txUniverse)
        : 0,
      txChainID: isSet(object.txChainID)
        ? bytesFromBase64(object.txChainID)
        : new Uint8Array(0),
      packet: isSet(object.depositPacket)
        ? {
            $case: "depositPacket",
            value: DepositVEPacket.fromJSON(object.depositPacket),
          }
        : isSet(object.fillPacket)
          ? {
              $case: "fillPacket",
              value: FillVEPacket.fromJSON(object.fillPacket),
            }
          : undefined,
    };
  },

  toJSON(message: MsgDoubleCheckTx): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.txUniverse !== 0) {
      obj.txUniverse = universeToJSON(message.txUniverse);
    }
    if (message.txChainID.length !== 0) {
      obj.txChainID = base64FromBytes(message.txChainID);
    }
    if (message.packet?.$case === "depositPacket") {
      obj.depositPacket = DepositVEPacket.toJSON(message.packet.value);
    } else if (message.packet?.$case === "fillPacket") {
      obj.fillPacket = FillVEPacket.toJSON(message.packet.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDoubleCheckTx>, I>>(
    base?: I,
  ): MsgDoubleCheckTx {
    return MsgDoubleCheckTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDoubleCheckTx>, I>>(
    object: I,
  ): MsgDoubleCheckTx {
    const message = createBaseMsgDoubleCheckTx();
    message.creator = object.creator ?? "";
    message.txUniverse = object.txUniverse ?? 0;
    message.txChainID = object.txChainID ?? new Uint8Array(0);
    switch (object.packet?.$case) {
      case "depositPacket": {
        if (
          object.packet?.value !== undefined &&
          object.packet?.value !== null
        ) {
          message.packet = {
            $case: "depositPacket",
            value: DepositVEPacket.fromPartial(object.packet.value),
          };
        }
        break;
      }
      case "fillPacket": {
        if (
          object.packet?.value !== undefined &&
          object.packet?.value !== null
        ) {
          message.packet = {
            $case: "fillPacket",
            value: FillVEPacket.fromPartial(object.packet.value),
          };
        }
        break;
      }
    }
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends { $case: string; value: unknown }
          ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
          : T extends {}
            ? { [K in keyof T]?: DeepPartial<T[K]> }
            : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
