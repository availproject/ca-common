// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.33.1
// source: definition.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "";

export enum RFFSourceState {
  WAITING = 0,
  DEPOSITED = 1,
  UNRECOGNIZED = -1,
}

export function rFFSourceStateFromJSON(object: any): RFFSourceState {
  switch (object) {
    case 0:
    case "WAITING":
      return RFFSourceState.WAITING;
    case 1:
    case "DEPOSITED":
      return RFFSourceState.DEPOSITED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RFFSourceState.UNRECOGNIZED;
  }
}

export function rFFSourceStateToJSON(object: RFFSourceState): string {
  switch (object) {
    case RFFSourceState.WAITING:
      return "WAITING";
    case RFFSourceState.DEPOSITED:
      return "DEPOSITED";
    case RFFSourceState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Universe {
  ETHEREUM = 0,
  FUEL = 1,
  SOLANA = 2,
  TRON = 3,
  UNRECOGNIZED = -1,
}

export function universeFromJSON(object: any): Universe {
  switch (object) {
    case 0:
    case "ETHEREUM":
      return Universe.ETHEREUM;
    case 1:
    case "FUEL":
      return Universe.FUEL;
    case 2:
    case "SOLANA":
      return Universe.SOLANA;
    case 3:
    case "TRON":
      return Universe.TRON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Universe.UNRECOGNIZED;
  }
}

export function universeToJSON(object: Universe): string {
  switch (object) {
    case Universe.ETHEREUM:
      return "ETHEREUM";
    case Universe.FUEL:
      return "FUEL";
    case Universe.SOLANA:
      return "SOLANA";
    case Universe.TRON:
      return "TRON";
    case Universe.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
  /**
   * key is a value returned in PageResponse.next_key to begin
   * querying the next page most efficiently. Only one of offset or key
   * should be set.
   */
  key: Uint8Array;
  /**
   * offset is a numeric offset that can be used when key is unavailable.
   * It is less efficient than using key. Only one of offset or key should
   * be set.
   */
  offset: Long;
  /**
   * limit is the total number of results to be returned in the result page.
   * If left empty it will default to a value to be set by each app.
   */
  limit: Long;
  /**
   * count_total is set to true  to indicate that the result set should include
   * a count of the total number of items available for pagination in UIs.
   * count_total is only respected when offset is used. It is ignored when key
   * is set.
   */
  countTotal: boolean;
  /** reverse is set to true if results are to be returned in the descending order. */
  reverse: boolean;
}

/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
  /**
   * next_key is the key to be passed to PageRequest.key to
   * query the next page most efficiently. It will be empty if
   * there are no more results.
   */
  nextKey: Uint8Array;
  /**
   * total is total number of results available if PageRequest.count_total
   * was set, its value is undefined otherwise
   */
  total: Long;
}

export interface RFFSourcePair {
  universe: Universe;
  chainID: Uint8Array;
  contractAddress: Uint8Array;
  value: Uint8Array;
  status: RFFSourceState;
}

export interface SignatureDatum {
  universe: Universe;
  address: Uint8Array;
  /** WARNING: This is NOT validated by Cosmos any more */
  signature: Uint8Array;
  /** is to be left empty by the creator and is to be filled in during signature verification */
  hash: Uint8Array;
}

export interface RFFDestinationPair {
  contractAddress: Uint8Array;
  /** amount */
  value: Uint8Array;
}

export interface RequestForFunds {
  id: Long;
  sources: RFFSourcePair[];
  destinationUniverse: Universe;
  destinationChainID: Uint8Array;
  recipientAddress: Uint8Array;
  destinations: RFFDestinationPair[];
  nonce: Uint8Array;
  expiry: Long;
  signatureData: SignatureDatum[];
  /** Cosmos user (???)/Cosmos internal fields */
  user: string;
  /** the EVM address that fulfilled it on the destination chain */
  fulfilledBy: Uint8Array;
  fulfilledAt: Long;
  deposited: boolean;
  fulfilled: boolean;
  settled: boolean;
  refunded: boolean;
  creationBlock: Long;
}

export interface RFFCreatedEvent {
  id: Long;
}

export interface RFFAllDepositsCompleteEvent {
  id: Long;
}

export interface RFFFulfilledEvent {
  id: Long;
}

export interface RouteFee {
  sourceUniverse: Universe;
  destinationUniverse: Universe;
  sourceChainID: Uint8Array;
  destinationChainID: Uint8Array;
  sourceTokenAddress: Uint8Array;
  destinationTokenAddress: Uint8Array;
  /** 7 â†” 9 are reserved for new fields */
  feeBP: number;
}

export interface SolverAddress {
  universe: Universe;
  address: Uint8Array;
  signature: Uint8Array;
}

export interface SolverData {
  cosmosAddress: string;
  advertisedFees: RouteFee[];
  addresses: SolverAddress[];
}

/** Settlement defines the Settlement message. */
export interface Settlement {
  id: Uint8Array;
  universe: Universe;
  chainID: Uint8Array;
  amounts: Uint8Array[];
  contractAddresses: Uint8Array[];
  solvers: Uint8Array[];
}

export interface FixedFeeTuple {
  universe: Universe;
  chainID: Uint8Array;
  tokenAddress: Uint8Array;
  fee: Uint8Array;
}

export interface AdminFeeRecipient {
  universe: Universe;
  address: Uint8Array;
}

export interface ProtocolFees {
  feeBP: Long;
  collectionFees: FixedFeeTuple[];
  fulfilmentFees: FixedFeeTuple[];
  admin: string;
  feeRecipients: AdminFeeRecipient[];
}

export interface PendingSettlement {
  id: Long;
  universe: Universe;
  chainID: Uint8Array;
  contractAddress: Uint8Array;
  amount: Uint8Array;
  recipient: Uint8Array;
}

export interface FulfilmentClaim {}

export interface RefundClaim {}

export interface BasicClaim {
  RFFID: Long;
  claim?:
    | { $case: "fulfilmentClaim"; value: FulfilmentClaim }
    | { $case: "refundClaim"; value: RefundClaim }
    | undefined;
}

/** PendingClaims defines the PendingClaims message. */
export interface PendingClaims {
  id: Long;
  creator: string;
  claim?: BasicClaim | undefined;
  timestamp: Long;
  attempts: number;
}

export interface FulfilmentVerdict {
  depositedIndexes: number[];
  solverAddress: Uint8Array;
}

export interface RefundVerdict {
  depositedIndexes: number[];
}

export interface ClaimVerdict {
  approved: boolean;
  verdict?:
    | { $case: "fulfilmentVerdict"; value: FulfilmentVerdict }
    | { $case: "refundVerdict"; value: RefundVerdict }
    | undefined;
}

export interface ChainParams {
  chainID: Uint8Array;
  allTokensDisabled: boolean;
  disabledTokens: Uint8Array[];
}

export interface UniverseParams {
  universe: Universe;
  allChainsDisabled: boolean;
  chainParams: ChainParams[];
}

/** Params defines the parameters for the module. */
export interface Params {
  mpcAddress: Uint8Array;
  maxAttempts: number;
  settlementNo: number;
  newRFFDisabled: boolean;
  universeParams: UniverseParams[];
}

function createBasePageRequest(): PageRequest {
  return {
    key: new Uint8Array(0),
    offset: Long.UZERO,
    limit: Long.UZERO,
    countTotal: false,
    reverse: false,
  };
}

export const PageRequest: MessageFns<PageRequest> = {
  encode(
    message: PageRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (!message.offset.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.offset.toString());
    }
    if (!message.limit.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.limit.toString());
    }
    if (message.countTotal !== false) {
      writer.uint32(32).bool(message.countTotal);
    }
    if (message.reverse !== false) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.countTotal = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reverse = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageRequest {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.UZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.UZERO,
      countTotal: isSet(object.countTotal)
        ? globalThis.Boolean(object.countTotal)
        : false,
      reverse: isSet(object.reverse)
        ? globalThis.Boolean(object.reverse)
        : false,
    };
  },

  toJSON(message: PageRequest): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (!message.offset.equals(Long.UZERO)) {
      obj.offset = (message.offset || Long.UZERO).toString();
    }
    if (!message.limit.equals(Long.UZERO)) {
      obj.limit = (message.limit || Long.UZERO).toString();
    }
    if (message.countTotal !== false) {
      obj.countTotal = message.countTotal;
    }
    if (message.reverse !== false) {
      obj.reverse = message.reverse;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PageRequest>, I>>(base?: I): PageRequest {
    return PageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PageRequest>, I>>(
    object: I,
  ): PageRequest {
    const message = createBasePageRequest();
    message.key = object.key ?? new Uint8Array(0);
    message.offset =
      object.offset !== undefined && object.offset !== null
        ? Long.fromValue(object.offset)
        : Long.UZERO;
    message.limit =
      object.limit !== undefined && object.limit !== null
        ? Long.fromValue(object.limit)
        : Long.UZERO;
    message.countTotal = object.countTotal ?? false;
    message.reverse = object.reverse ?? false;
    return message;
  },
};

function createBasePageResponse(): PageResponse {
  return { nextKey: new Uint8Array(0), total: Long.UZERO };
}

export const PageResponse: MessageFns<PageResponse> = {
  encode(
    message: PageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nextKey.length !== 0) {
      writer.uint32(10).bytes(message.nextKey);
    }
    if (!message.total.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.total.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nextKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageResponse {
    return {
      nextKey: isSet(object.nextKey)
        ? bytesFromBase64(object.nextKey)
        : new Uint8Array(0),
      total: isSet(object.total) ? Long.fromValue(object.total) : Long.UZERO,
    };
  },

  toJSON(message: PageResponse): unknown {
    const obj: any = {};
    if (message.nextKey.length !== 0) {
      obj.nextKey = base64FromBytes(message.nextKey);
    }
    if (!message.total.equals(Long.UZERO)) {
      obj.total = (message.total || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PageResponse>, I>>(
    base?: I,
  ): PageResponse {
    return PageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PageResponse>, I>>(
    object: I,
  ): PageResponse {
    const message = createBasePageResponse();
    message.nextKey = object.nextKey ?? new Uint8Array(0);
    message.total =
      object.total !== undefined && object.total !== null
        ? Long.fromValue(object.total)
        : Long.UZERO;
    return message;
  },
};

function createBaseRFFSourcePair(): RFFSourcePair {
  return {
    universe: 0,
    chainID: new Uint8Array(0),
    contractAddress: new Uint8Array(0),
    value: new Uint8Array(0),
    status: 0,
  };
}

export const RFFSourcePair: MessageFns<RFFSourcePair> = {
  encode(
    message: RFFSourcePair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(18).bytes(message.chainID);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(26).bytes(message.contractAddress);
    }
    if (message.value.length !== 0) {
      writer.uint32(34).bytes(message.value);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RFFSourcePair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFSourcePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFSourcePair {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      contractAddress: isSet(object.contractAddress)
        ? bytesFromBase64(object.contractAddress)
        : new Uint8Array(0),
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
      status: isSet(object.status) ? rFFSourceStateFromJSON(object.status) : 0,
    };
  },

  toJSON(message: RFFSourcePair): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.status !== 0) {
      obj.status = rFFSourceStateToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFSourcePair>, I>>(
    base?: I,
  ): RFFSourcePair {
    return RFFSourcePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFSourcePair>, I>>(
    object: I,
  ): RFFSourcePair {
    const message = createBaseRFFSourcePair();
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.contractAddress = object.contractAddress ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseSignatureDatum(): SignatureDatum {
  return {
    universe: 0,
    address: new Uint8Array(0),
    signature: new Uint8Array(0),
    hash: new Uint8Array(0),
  };
}

export const SignatureDatum: MessageFns<SignatureDatum> = {
  encode(
    message: SignatureDatum,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    if (message.hash.length !== 0) {
      writer.uint32(34).bytes(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureDatum {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureDatum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureDatum {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
      hash: isSet(object.hash)
        ? bytesFromBase64(object.hash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SignatureDatum): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignatureDatum>, I>>(
    base?: I,
  ): SignatureDatum {
    return SignatureDatum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignatureDatum>, I>>(
    object: I,
  ): SignatureDatum {
    const message = createBaseSignatureDatum();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.hash = object.hash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRFFDestinationPair(): RFFDestinationPair {
  return { contractAddress: new Uint8Array(0), value: new Uint8Array(0) };
}

export const RFFDestinationPair: MessageFns<RFFDestinationPair> = {
  encode(
    message: RFFDestinationPair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.contractAddress.length !== 0) {
      writer.uint32(10).bytes(message.contractAddress);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RFFDestinationPair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFDestinationPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFDestinationPair {
    return {
      contractAddress: isSet(object.contractAddress)
        ? bytesFromBase64(object.contractAddress)
        : new Uint8Array(0),
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
    };
  },

  toJSON(message: RFFDestinationPair): unknown {
    const obj: any = {};
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFDestinationPair>, I>>(
    base?: I,
  ): RFFDestinationPair {
    return RFFDestinationPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFDestinationPair>, I>>(
    object: I,
  ): RFFDestinationPair {
    const message = createBaseRFFDestinationPair();
    message.contractAddress = object.contractAddress ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestForFunds(): RequestForFunds {
  return {
    id: Long.UZERO,
    sources: [],
    destinationUniverse: 0,
    destinationChainID: new Uint8Array(0),
    recipientAddress: new Uint8Array(0),
    destinations: [],
    nonce: new Uint8Array(0),
    expiry: Long.UZERO,
    signatureData: [],
    user: "",
    fulfilledBy: new Uint8Array(0),
    fulfilledAt: Long.UZERO,
    deposited: false,
    fulfilled: false,
    settled: false,
    refunded: false,
    creationBlock: Long.ZERO,
  };
}

export const RequestForFunds: MessageFns<RequestForFunds> = {
  encode(
    message: RequestForFunds,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    for (const v of message.sources) {
      RFFSourcePair.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.destinationUniverse !== 0) {
      writer.uint32(72).int32(message.destinationUniverse);
    }
    if (message.destinationChainID.length !== 0) {
      writer.uint32(26).bytes(message.destinationChainID);
    }
    if (message.recipientAddress.length !== 0) {
      writer.uint32(90).bytes(message.recipientAddress);
    }
    for (const v of message.destinations) {
      RFFDestinationPair.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.expiry.toString());
    }
    for (const v of message.signatureData) {
      SignatureDatum.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.user !== "") {
      writer.uint32(810).string(message.user);
    }
    if (message.fulfilledBy.length !== 0) {
      writer.uint32(818).bytes(message.fulfilledBy);
    }
    if (!message.fulfilledAt.equals(Long.UZERO)) {
      writer.uint32(824).uint64(message.fulfilledAt.toString());
    }
    if (message.deposited !== false) {
      writer.uint32(832).bool(message.deposited);
    }
    if (message.fulfilled !== false) {
      writer.uint32(840).bool(message.fulfilled);
    }
    if (message.settled !== false) {
      writer.uint32(848).bool(message.settled);
    }
    if (message.refunded !== false) {
      writer.uint32(856).bool(message.refunded);
    }
    if (!message.creationBlock.equals(Long.ZERO)) {
      writer.uint32(872).int64(message.creationBlock.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestForFunds {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestForFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sources.push(RFFSourcePair.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.destinationUniverse = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationChainID = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.recipientAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinations.push(
            RFFDestinationPair.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiry = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.signatureData.push(
            SignatureDatum.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.fulfilledBy = reader.bytes();
          continue;
        }
        case 103: {
          if (tag !== 824) {
            break;
          }

          message.fulfilledAt = Long.fromString(
            reader.uint64().toString(),
            true,
          );
          continue;
        }
        case 104: {
          if (tag !== 832) {
            break;
          }

          message.deposited = reader.bool();
          continue;
        }
        case 105: {
          if (tag !== 840) {
            break;
          }

          message.fulfilled = reader.bool();
          continue;
        }
        case 106: {
          if (tag !== 848) {
            break;
          }

          message.settled = reader.bool();
          continue;
        }
        case 107: {
          if (tag !== 856) {
            break;
          }

          message.refunded = reader.bool();
          continue;
        }
        case 109: {
          if (tag !== 872) {
            break;
          }

          message.creationBlock = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestForFunds {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => RFFSourcePair.fromJSON(e))
        : [],
      destinationUniverse: isSet(object.destinationUniverse)
        ? universeFromJSON(object.destinationUniverse)
        : 0,
      destinationChainID: isSet(object.destinationChainID)
        ? bytesFromBase64(object.destinationChainID)
        : new Uint8Array(0),
      recipientAddress: isSet(object.recipientAddress)
        ? bytesFromBase64(object.recipientAddress)
        : new Uint8Array(0),
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => RFFDestinationPair.fromJSON(e))
        : [],
      nonce: isSet(object.nonce)
        ? bytesFromBase64(object.nonce)
        : new Uint8Array(0),
      expiry: isSet(object.expiry) ? Long.fromValue(object.expiry) : Long.UZERO,
      signatureData: globalThis.Array.isArray(object?.signatureData)
        ? object.signatureData.map((e: any) => SignatureDatum.fromJSON(e))
        : [],
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      fulfilledBy: isSet(object.fulfilledBy)
        ? bytesFromBase64(object.fulfilledBy)
        : new Uint8Array(0),
      fulfilledAt: isSet(object.fulfilledAt)
        ? Long.fromValue(object.fulfilledAt)
        : Long.UZERO,
      deposited: isSet(object.deposited)
        ? globalThis.Boolean(object.deposited)
        : false,
      fulfilled: isSet(object.fulfilled)
        ? globalThis.Boolean(object.fulfilled)
        : false,
      settled: isSet(object.settled)
        ? globalThis.Boolean(object.settled)
        : false,
      refunded: isSet(object.refunded)
        ? globalThis.Boolean(object.refunded)
        : false,
      creationBlock: isSet(object.creationBlock)
        ? Long.fromValue(object.creationBlock)
        : Long.ZERO,
    };
  },

  toJSON(message: RequestForFunds): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => RFFSourcePair.toJSON(e));
    }
    if (message.destinationUniverse !== 0) {
      obj.destinationUniverse = universeToJSON(message.destinationUniverse);
    }
    if (message.destinationChainID.length !== 0) {
      obj.destinationChainID = base64FromBytes(message.destinationChainID);
    }
    if (message.recipientAddress.length !== 0) {
      obj.recipientAddress = base64FromBytes(message.recipientAddress);
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) =>
        RFFDestinationPair.toJSON(e),
      );
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      obj.expiry = (message.expiry || Long.UZERO).toString();
    }
    if (message.signatureData?.length) {
      obj.signatureData = message.signatureData.map((e) =>
        SignatureDatum.toJSON(e),
      );
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.fulfilledBy.length !== 0) {
      obj.fulfilledBy = base64FromBytes(message.fulfilledBy);
    }
    if (!message.fulfilledAt.equals(Long.UZERO)) {
      obj.fulfilledAt = (message.fulfilledAt || Long.UZERO).toString();
    }
    if (message.deposited !== false) {
      obj.deposited = message.deposited;
    }
    if (message.fulfilled !== false) {
      obj.fulfilled = message.fulfilled;
    }
    if (message.settled !== false) {
      obj.settled = message.settled;
    }
    if (message.refunded !== false) {
      obj.refunded = message.refunded;
    }
    if (!message.creationBlock.equals(Long.ZERO)) {
      obj.creationBlock = (message.creationBlock || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestForFunds>, I>>(
    base?: I,
  ): RequestForFunds {
    return RequestForFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestForFunds>, I>>(
    object: I,
  ): RequestForFunds {
    const message = createBaseRequestForFunds();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.sources =
      object.sources?.map((e) => RFFSourcePair.fromPartial(e)) || [];
    message.destinationUniverse = object.destinationUniverse ?? 0;
    message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
    message.recipientAddress = object.recipientAddress ?? new Uint8Array(0);
    message.destinations =
      object.destinations?.map((e) => RFFDestinationPair.fromPartial(e)) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.expiry =
      object.expiry !== undefined && object.expiry !== null
        ? Long.fromValue(object.expiry)
        : Long.UZERO;
    message.signatureData =
      object.signatureData?.map((e) => SignatureDatum.fromPartial(e)) || [];
    message.user = object.user ?? "";
    message.fulfilledBy = object.fulfilledBy ?? new Uint8Array(0);
    message.fulfilledAt =
      object.fulfilledAt !== undefined && object.fulfilledAt !== null
        ? Long.fromValue(object.fulfilledAt)
        : Long.UZERO;
    message.deposited = object.deposited ?? false;
    message.fulfilled = object.fulfilled ?? false;
    message.settled = object.settled ?? false;
    message.refunded = object.refunded ?? false;
    message.creationBlock =
      object.creationBlock !== undefined && object.creationBlock !== null
        ? Long.fromValue(object.creationBlock)
        : Long.ZERO;
    return message;
  },
};

function createBaseRFFCreatedEvent(): RFFCreatedEvent {
  return { id: Long.UZERO };
}

export const RFFCreatedEvent: MessageFns<RFFCreatedEvent> = {
  encode(
    message: RFFCreatedEvent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RFFCreatedEvent {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFCreatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFCreatedEvent {
    return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
  },

  toJSON(message: RFFCreatedEvent): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFCreatedEvent>, I>>(
    base?: I,
  ): RFFCreatedEvent {
    return RFFCreatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFCreatedEvent>, I>>(
    object: I,
  ): RFFCreatedEvent {
    const message = createBaseRFFCreatedEvent();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    return message;
  },
};

function createBaseRFFAllDepositsCompleteEvent(): RFFAllDepositsCompleteEvent {
  return { id: Long.UZERO };
}

export const RFFAllDepositsCompleteEvent: MessageFns<RFFAllDepositsCompleteEvent> =
  {
    encode(
      message: RFFAllDepositsCompleteEvent,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): RFFAllDepositsCompleteEvent {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRFFAllDepositsCompleteEvent();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): RFFAllDepositsCompleteEvent {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: RFFAllDepositsCompleteEvent): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<RFFAllDepositsCompleteEvent>, I>>(
      base?: I,
    ): RFFAllDepositsCompleteEvent {
      return RFFAllDepositsCompleteEvent.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<RFFAllDepositsCompleteEvent>, I>>(
      object: I,
    ): RFFAllDepositsCompleteEvent {
      const message = createBaseRFFAllDepositsCompleteEvent();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseRFFFulfilledEvent(): RFFFulfilledEvent {
  return { id: Long.UZERO };
}

export const RFFFulfilledEvent: MessageFns<RFFFulfilledEvent> = {
  encode(
    message: RFFFulfilledEvent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RFFFulfilledEvent {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFFulfilledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFFulfilledEvent {
    return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
  },

  toJSON(message: RFFFulfilledEvent): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFFulfilledEvent>, I>>(
    base?: I,
  ): RFFFulfilledEvent {
    return RFFFulfilledEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFFulfilledEvent>, I>>(
    object: I,
  ): RFFFulfilledEvent {
    const message = createBaseRFFFulfilledEvent();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    return message;
  },
};

function createBaseRouteFee(): RouteFee {
  return {
    sourceUniverse: 0,
    destinationUniverse: 0,
    sourceChainID: new Uint8Array(0),
    destinationChainID: new Uint8Array(0),
    sourceTokenAddress: new Uint8Array(0),
    destinationTokenAddress: new Uint8Array(0),
    feeBP: 0,
  };
}

export const RouteFee: MessageFns<RouteFee> = {
  encode(
    message: RouteFee,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceUniverse !== 0) {
      writer.uint32(8).int32(message.sourceUniverse);
    }
    if (message.destinationUniverse !== 0) {
      writer.uint32(16).int32(message.destinationUniverse);
    }
    if (message.sourceChainID.length !== 0) {
      writer.uint32(26).bytes(message.sourceChainID);
    }
    if (message.destinationChainID.length !== 0) {
      writer.uint32(34).bytes(message.destinationChainID);
    }
    if (message.sourceTokenAddress.length !== 0) {
      writer.uint32(42).bytes(message.sourceTokenAddress);
    }
    if (message.destinationTokenAddress.length !== 0) {
      writer.uint32(50).bytes(message.destinationTokenAddress);
    }
    if (message.feeBP !== 0) {
      writer.uint32(80).uint32(message.feeBP);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteFee {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sourceUniverse = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.destinationUniverse = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceChainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinationChainID = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sourceTokenAddress = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destinationTokenAddress = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.feeBP = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteFee {
    return {
      sourceUniverse: isSet(object.sourceUniverse)
        ? universeFromJSON(object.sourceUniverse)
        : 0,
      destinationUniverse: isSet(object.destinationUniverse)
        ? universeFromJSON(object.destinationUniverse)
        : 0,
      sourceChainID: isSet(object.sourceChainID)
        ? bytesFromBase64(object.sourceChainID)
        : new Uint8Array(0),
      destinationChainID: isSet(object.destinationChainID)
        ? bytesFromBase64(object.destinationChainID)
        : new Uint8Array(0),
      sourceTokenAddress: isSet(object.sourceTokenAddress)
        ? bytesFromBase64(object.sourceTokenAddress)
        : new Uint8Array(0),
      destinationTokenAddress: isSet(object.destinationTokenAddress)
        ? bytesFromBase64(object.destinationTokenAddress)
        : new Uint8Array(0),
      feeBP: isSet(object.feeBP) ? globalThis.Number(object.feeBP) : 0,
    };
  },

  toJSON(message: RouteFee): unknown {
    const obj: any = {};
    if (message.sourceUniverse !== 0) {
      obj.sourceUniverse = universeToJSON(message.sourceUniverse);
    }
    if (message.destinationUniverse !== 0) {
      obj.destinationUniverse = universeToJSON(message.destinationUniverse);
    }
    if (message.sourceChainID.length !== 0) {
      obj.sourceChainID = base64FromBytes(message.sourceChainID);
    }
    if (message.destinationChainID.length !== 0) {
      obj.destinationChainID = base64FromBytes(message.destinationChainID);
    }
    if (message.sourceTokenAddress.length !== 0) {
      obj.sourceTokenAddress = base64FromBytes(message.sourceTokenAddress);
    }
    if (message.destinationTokenAddress.length !== 0) {
      obj.destinationTokenAddress = base64FromBytes(
        message.destinationTokenAddress,
      );
    }
    if (message.feeBP !== 0) {
      obj.feeBP = Math.round(message.feeBP);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteFee>, I>>(base?: I): RouteFee {
    return RouteFee.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteFee>, I>>(object: I): RouteFee {
    const message = createBaseRouteFee();
    message.sourceUniverse = object.sourceUniverse ?? 0;
    message.destinationUniverse = object.destinationUniverse ?? 0;
    message.sourceChainID = object.sourceChainID ?? new Uint8Array(0);
    message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
    message.sourceTokenAddress = object.sourceTokenAddress ?? new Uint8Array(0);
    message.destinationTokenAddress =
      object.destinationTokenAddress ?? new Uint8Array(0);
    message.feeBP = object.feeBP ?? 0;
    return message;
  },
};

function createBaseSolverAddress(): SolverAddress {
  return {
    universe: 0,
    address: new Uint8Array(0),
    signature: new Uint8Array(0),
  };
}

export const SolverAddress: MessageFns<SolverAddress> = {
  encode(
    message: SolverAddress,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolverAddress {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolverAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolverAddress {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SolverAddress): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolverAddress>, I>>(
    base?: I,
  ): SolverAddress {
    return SolverAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolverAddress>, I>>(
    object: I,
  ): SolverAddress {
    const message = createBaseSolverAddress();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSolverData(): SolverData {
  return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}

export const SolverData: MessageFns<SolverData> = {
  encode(
    message: SolverData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cosmosAddress !== "") {
      writer.uint32(10).string(message.cosmosAddress);
    }
    for (const v of message.advertisedFees) {
      RouteFee.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.addresses) {
      SolverAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolverData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolverData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cosmosAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.advertisedFees.push(RouteFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(SolverAddress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolverData {
    return {
      cosmosAddress: isSet(object.cosmosAddress)
        ? globalThis.String(object.cosmosAddress)
        : "",
      advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
        ? object.advertisedFees.map((e: any) => RouteFee.fromJSON(e))
        : [],
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => SolverAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SolverData): unknown {
    const obj: any = {};
    if (message.cosmosAddress !== "") {
      obj.cosmosAddress = message.cosmosAddress;
    }
    if (message.advertisedFees?.length) {
      obj.advertisedFees = message.advertisedFees.map((e) =>
        RouteFee.toJSON(e),
      );
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => SolverAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolverData>, I>>(base?: I): SolverData {
    return SolverData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolverData>, I>>(
    object: I,
  ): SolverData {
    const message = createBaseSolverData();
    message.cosmosAddress = object.cosmosAddress ?? "";
    message.advertisedFees =
      object.advertisedFees?.map((e) => RouteFee.fromPartial(e)) || [];
    message.addresses =
      object.addresses?.map((e) => SolverAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSettlement(): Settlement {
  return {
    id: new Uint8Array(0),
    universe: 0,
    chainID: new Uint8Array(0),
    amounts: [],
    contractAddresses: [],
    solvers: [],
  };
}

export const Settlement: MessageFns<Settlement> = {
  encode(
    message: Settlement,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.universe !== 0) {
      writer.uint32(16).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(26).bytes(message.chainID);
    }
    for (const v of message.amounts) {
      writer.uint32(34).bytes(v!);
    }
    for (const v of message.contractAddresses) {
      writer.uint32(42).bytes(v!);
    }
    for (const v of message.solvers) {
      writer.uint32(50).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settlement {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettlement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amounts.push(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractAddresses.push(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.solvers.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settlement {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      amounts: globalThis.Array.isArray(object?.amounts)
        ? object.amounts.map((e: any) => bytesFromBase64(e))
        : [],
      contractAddresses: globalThis.Array.isArray(object?.contractAddresses)
        ? object.contractAddresses.map((e: any) => bytesFromBase64(e))
        : [],
      solvers: globalThis.Array.isArray(object?.solvers)
        ? object.solvers.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: Settlement): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.amounts?.length) {
      obj.amounts = message.amounts.map((e) => base64FromBytes(e));
    }
    if (message.contractAddresses?.length) {
      obj.contractAddresses = message.contractAddresses.map((e) =>
        base64FromBytes(e),
      );
    }
    if (message.solvers?.length) {
      obj.solvers = message.solvers.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Settlement>, I>>(base?: I): Settlement {
    return Settlement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Settlement>, I>>(
    object: I,
  ): Settlement {
    const message = createBaseSettlement();
    message.id = object.id ?? new Uint8Array(0);
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.amounts = object.amounts?.map((e) => e) || [];
    message.contractAddresses = object.contractAddresses?.map((e) => e) || [];
    message.solvers = object.solvers?.map((e) => e) || [];
    return message;
  },
};

function createBaseFixedFeeTuple(): FixedFeeTuple {
  return {
    universe: 0,
    chainID: new Uint8Array(0),
    tokenAddress: new Uint8Array(0),
    fee: new Uint8Array(0),
  };
}

export const FixedFeeTuple: MessageFns<FixedFeeTuple> = {
  encode(
    message: FixedFeeTuple,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(18).bytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      writer.uint32(26).bytes(message.tokenAddress);
    }
    if (message.fee.length !== 0) {
      writer.uint32(34).bytes(message.fee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixedFeeTuple {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixedFeeTuple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fee = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixedFeeTuple {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      tokenAddress: isSet(object.tokenAddress)
        ? bytesFromBase64(object.tokenAddress)
        : new Uint8Array(0),
      fee: isSet(object.fee) ? bytesFromBase64(object.fee) : new Uint8Array(0),
    };
  },

  toJSON(message: FixedFeeTuple): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    if (message.fee.length !== 0) {
      obj.fee = base64FromBytes(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FixedFeeTuple>, I>>(
    base?: I,
  ): FixedFeeTuple {
    return FixedFeeTuple.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FixedFeeTuple>, I>>(
    object: I,
  ): FixedFeeTuple {
    const message = createBaseFixedFeeTuple();
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
    message.fee = object.fee ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAdminFeeRecipient(): AdminFeeRecipient {
  return { universe: 0, address: new Uint8Array(0) };
}

export const AdminFeeRecipient: MessageFns<AdminFeeRecipient> = {
  encode(
    message: AdminFeeRecipient,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminFeeRecipient {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminFeeRecipient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminFeeRecipient {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
    };
  },

  toJSON(message: AdminFeeRecipient): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminFeeRecipient>, I>>(
    base?: I,
  ): AdminFeeRecipient {
    return AdminFeeRecipient.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminFeeRecipient>, I>>(
    object: I,
  ): AdminFeeRecipient {
    const message = createBaseAdminFeeRecipient();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProtocolFees(): ProtocolFees {
  return {
    feeBP: Long.UZERO,
    collectionFees: [],
    fulfilmentFees: [],
    admin: "",
    feeRecipients: [],
  };
}

export const ProtocolFees: MessageFns<ProtocolFees> = {
  encode(
    message: ProtocolFees,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.feeBP.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.feeBP.toString());
    }
    for (const v of message.collectionFees) {
      FixedFeeTuple.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.fulfilmentFees) {
      FixedFeeTuple.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.admin !== "") {
      writer.uint32(34).string(message.admin);
    }
    for (const v of message.feeRecipients) {
      AdminFeeRecipient.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtocolFees {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocolFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.feeBP = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collectionFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fulfilmentFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feeRecipients.push(
            AdminFeeRecipient.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtocolFees {
    return {
      feeBP: isSet(object.feeBP) ? Long.fromValue(object.feeBP) : Long.UZERO,
      collectionFees: globalThis.Array.isArray(object?.collectionFees)
        ? object.collectionFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
        ? object.fulfilmentFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
        ? object.feeRecipients.map((e: any) => AdminFeeRecipient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProtocolFees): unknown {
    const obj: any = {};
    if (!message.feeBP.equals(Long.UZERO)) {
      obj.feeBP = (message.feeBP || Long.UZERO).toString();
    }
    if (message.collectionFees?.length) {
      obj.collectionFees = message.collectionFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.fulfilmentFees?.length) {
      obj.fulfilmentFees = message.fulfilmentFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.feeRecipients?.length) {
      obj.feeRecipients = message.feeRecipients.map((e) =>
        AdminFeeRecipient.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtocolFees>, I>>(
    base?: I,
  ): ProtocolFees {
    return ProtocolFees.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtocolFees>, I>>(
    object: I,
  ): ProtocolFees {
    const message = createBaseProtocolFees();
    message.feeBP =
      object.feeBP !== undefined && object.feeBP !== null
        ? Long.fromValue(object.feeBP)
        : Long.UZERO;
    message.collectionFees =
      object.collectionFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.fulfilmentFees =
      object.fulfilmentFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.admin = object.admin ?? "";
    message.feeRecipients =
      object.feeRecipients?.map((e) => AdminFeeRecipient.fromPartial(e)) || [];
    return message;
  },
};

function createBasePendingSettlement(): PendingSettlement {
  return {
    id: Long.UZERO,
    universe: 0,
    chainID: new Uint8Array(0),
    contractAddress: new Uint8Array(0),
    amount: new Uint8Array(0),
    recipient: new Uint8Array(0),
  };
}

export const PendingSettlement: MessageFns<PendingSettlement> = {
  encode(
    message: PendingSettlement,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    if (message.universe !== 0) {
      writer.uint32(16).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(26).bytes(message.chainID);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(34).bytes(message.contractAddress);
    }
    if (message.amount.length !== 0) {
      writer.uint32(42).bytes(message.amount);
    }
    if (message.recipient.length !== 0) {
      writer.uint32(50).bytes(message.recipient);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingSettlement {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingSettlement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractAddress = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recipient = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingSettlement {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      contractAddress: isSet(object.contractAddress)
        ? bytesFromBase64(object.contractAddress)
        : new Uint8Array(0),
      amount: isSet(object.amount)
        ? bytesFromBase64(object.amount)
        : new Uint8Array(0),
      recipient: isSet(object.recipient)
        ? bytesFromBase64(object.recipient)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PendingSettlement): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.recipient.length !== 0) {
      obj.recipient = base64FromBytes(message.recipient);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingSettlement>, I>>(
    base?: I,
  ): PendingSettlement {
    return PendingSettlement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingSettlement>, I>>(
    object: I,
  ): PendingSettlement {
    const message = createBasePendingSettlement();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.contractAddress = object.contractAddress ?? new Uint8Array(0);
    message.amount = object.amount ?? new Uint8Array(0);
    message.recipient = object.recipient ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFulfilmentClaim(): FulfilmentClaim {
  return {};
}

export const FulfilmentClaim: MessageFns<FulfilmentClaim> = {
  encode(
    _: FulfilmentClaim,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfilmentClaim {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfilmentClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FulfilmentClaim {
    return {};
  },

  toJSON(_: FulfilmentClaim): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FulfilmentClaim>, I>>(
    base?: I,
  ): FulfilmentClaim {
    return FulfilmentClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FulfilmentClaim>, I>>(
    _: I,
  ): FulfilmentClaim {
    const message = createBaseFulfilmentClaim();
    return message;
  },
};

function createBaseRefundClaim(): RefundClaim {
  return {};
}

export const RefundClaim: MessageFns<RefundClaim> = {
  encode(
    _: RefundClaim,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundClaim {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RefundClaim {
    return {};
  },

  toJSON(_: RefundClaim): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundClaim>, I>>(base?: I): RefundClaim {
    return RefundClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundClaim>, I>>(_: I): RefundClaim {
    const message = createBaseRefundClaim();
    return message;
  },
};

function createBaseBasicClaim(): BasicClaim {
  return { RFFID: Long.UZERO, claim: undefined };
}

export const BasicClaim: MessageFns<BasicClaim> = {
  encode(
    message: BasicClaim,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.RFFID.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.RFFID.toString());
    }
    switch (message.claim?.$case) {
      case "fulfilmentClaim":
        FulfilmentClaim.encode(
          message.claim.value,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "refundClaim":
        RefundClaim.encode(
          message.claim.value,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicClaim {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.RFFID = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claim = {
            $case: "fulfilmentClaim",
            value: FulfilmentClaim.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.claim = {
            $case: "refundClaim",
            value: RefundClaim.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicClaim {
    return {
      RFFID: isSet(object.RFFID) ? Long.fromValue(object.RFFID) : Long.UZERO,
      claim: isSet(object.fulfilmentClaim)
        ? {
            $case: "fulfilmentClaim",
            value: FulfilmentClaim.fromJSON(object.fulfilmentClaim),
          }
        : isSet(object.refundClaim)
          ? {
              $case: "refundClaim",
              value: RefundClaim.fromJSON(object.refundClaim),
            }
          : undefined,
    };
  },

  toJSON(message: BasicClaim): unknown {
    const obj: any = {};
    if (!message.RFFID.equals(Long.UZERO)) {
      obj.RFFID = (message.RFFID || Long.UZERO).toString();
    }
    if (message.claim?.$case === "fulfilmentClaim") {
      obj.fulfilmentClaim = FulfilmentClaim.toJSON(message.claim.value);
    } else if (message.claim?.$case === "refundClaim") {
      obj.refundClaim = RefundClaim.toJSON(message.claim.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasicClaim>, I>>(base?: I): BasicClaim {
    return BasicClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasicClaim>, I>>(
    object: I,
  ): BasicClaim {
    const message = createBaseBasicClaim();
    message.RFFID =
      object.RFFID !== undefined && object.RFFID !== null
        ? Long.fromValue(object.RFFID)
        : Long.UZERO;
    switch (object.claim?.$case) {
      case "fulfilmentClaim": {
        if (object.claim?.value !== undefined && object.claim?.value !== null) {
          message.claim = {
            $case: "fulfilmentClaim",
            value: FulfilmentClaim.fromPartial(object.claim.value),
          };
        }
        break;
      }
      case "refundClaim": {
        if (object.claim?.value !== undefined && object.claim?.value !== null) {
          message.claim = {
            $case: "refundClaim",
            value: RefundClaim.fromPartial(object.claim.value),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBasePendingClaims(): PendingClaims {
  return {
    id: Long.UZERO,
    creator: "",
    claim: undefined,
    timestamp: Long.UZERO,
    attempts: 0,
  };
}

export const PendingClaims: MessageFns<PendingClaims> = {
  encode(
    message: PendingClaims,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    if (message.creator !== "") {
      writer.uint32(18).string(message.creator);
    }
    if (message.claim !== undefined) {
      BasicClaim.encode(message.claim, writer.uint32(26).fork()).join();
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.timestamp.toString());
    }
    if (message.attempts !== 0) {
      writer.uint32(32).uint32(message.attempts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingClaims {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingClaims();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.claim = BasicClaim.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attempts = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingClaims {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      claim: isSet(object.claim)
        ? BasicClaim.fromJSON(object.claim)
        : undefined,
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.UZERO,
      attempts: isSet(object.attempts) ? globalThis.Number(object.attempts) : 0,
    };
  },

  toJSON(message: PendingClaims): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.claim !== undefined) {
      obj.claim = BasicClaim.toJSON(message.claim);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    if (message.attempts !== 0) {
      obj.attempts = Math.round(message.attempts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingClaims>, I>>(
    base?: I,
  ): PendingClaims {
    return PendingClaims.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingClaims>, I>>(
    object: I,
  ): PendingClaims {
    const message = createBasePendingClaims();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.creator = object.creator ?? "";
    message.claim =
      object.claim !== undefined && object.claim !== null
        ? BasicClaim.fromPartial(object.claim)
        : undefined;
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.UZERO;
    message.attempts = object.attempts ?? 0;
    return message;
  },
};

function createBaseFulfilmentVerdict(): FulfilmentVerdict {
  return { depositedIndexes: [], solverAddress: new Uint8Array(0) };
}

export const FulfilmentVerdict: MessageFns<FulfilmentVerdict> = {
  encode(
    message: FulfilmentVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.depositedIndexes) {
      writer.uint32(v);
    }
    writer.join();
    if (message.solverAddress.length !== 0) {
      writer.uint32(18).bytes(message.solverAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfilmentVerdict {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfilmentVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.depositedIndexes.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.depositedIndexes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.solverAddress = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfilmentVerdict {
    return {
      depositedIndexes: globalThis.Array.isArray(object?.depositedIndexes)
        ? object.depositedIndexes.map((e: any) => globalThis.Number(e))
        : [],
      solverAddress: isSet(object.solverAddress)
        ? bytesFromBase64(object.solverAddress)
        : new Uint8Array(0),
    };
  },

  toJSON(message: FulfilmentVerdict): unknown {
    const obj: any = {};
    if (message.depositedIndexes?.length) {
      obj.depositedIndexes = message.depositedIndexes.map((e) => Math.round(e));
    }
    if (message.solverAddress.length !== 0) {
      obj.solverAddress = base64FromBytes(message.solverAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FulfilmentVerdict>, I>>(
    base?: I,
  ): FulfilmentVerdict {
    return FulfilmentVerdict.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FulfilmentVerdict>, I>>(
    object: I,
  ): FulfilmentVerdict {
    const message = createBaseFulfilmentVerdict();
    message.depositedIndexes = object.depositedIndexes?.map((e) => e) || [];
    message.solverAddress = object.solverAddress ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRefundVerdict(): RefundVerdict {
  return { depositedIndexes: [] };
}

export const RefundVerdict: MessageFns<RefundVerdict> = {
  encode(
    message: RefundVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.depositedIndexes) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundVerdict {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.depositedIndexes.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.depositedIndexes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundVerdict {
    return {
      depositedIndexes: globalThis.Array.isArray(object?.depositedIndexes)
        ? object.depositedIndexes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: RefundVerdict): unknown {
    const obj: any = {};
    if (message.depositedIndexes?.length) {
      obj.depositedIndexes = message.depositedIndexes.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundVerdict>, I>>(
    base?: I,
  ): RefundVerdict {
    return RefundVerdict.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundVerdict>, I>>(
    object: I,
  ): RefundVerdict {
    const message = createBaseRefundVerdict();
    message.depositedIndexes = object.depositedIndexes?.map((e) => e) || [];
    return message;
  },
};

function createBaseClaimVerdict(): ClaimVerdict {
  return { approved: false, verdict: undefined };
}

export const ClaimVerdict: MessageFns<ClaimVerdict> = {
  encode(
    message: ClaimVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.approved !== false) {
      writer.uint32(8).bool(message.approved);
    }
    switch (message.verdict?.$case) {
      case "fulfilmentVerdict":
        FulfilmentVerdict.encode(
          message.verdict.value,
          writer.uint32(82).fork(),
        ).join();
        break;
      case "refundVerdict":
        RefundVerdict.encode(
          message.verdict.value,
          writer.uint32(90).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimVerdict {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.approved = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.verdict = {
            $case: "fulfilmentVerdict",
            value: FulfilmentVerdict.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.verdict = {
            $case: "refundVerdict",
            value: RefundVerdict.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimVerdict {
    return {
      approved: isSet(object.approved)
        ? globalThis.Boolean(object.approved)
        : false,
      verdict: isSet(object.fulfilmentVerdict)
        ? {
            $case: "fulfilmentVerdict",
            value: FulfilmentVerdict.fromJSON(object.fulfilmentVerdict),
          }
        : isSet(object.refundVerdict)
          ? {
              $case: "refundVerdict",
              value: RefundVerdict.fromJSON(object.refundVerdict),
            }
          : undefined,
    };
  },

  toJSON(message: ClaimVerdict): unknown {
    const obj: any = {};
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    if (message.verdict?.$case === "fulfilmentVerdict") {
      obj.fulfilmentVerdict = FulfilmentVerdict.toJSON(message.verdict.value);
    } else if (message.verdict?.$case === "refundVerdict") {
      obj.refundVerdict = RefundVerdict.toJSON(message.verdict.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimVerdict>, I>>(
    base?: I,
  ): ClaimVerdict {
    return ClaimVerdict.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimVerdict>, I>>(
    object: I,
  ): ClaimVerdict {
    const message = createBaseClaimVerdict();
    message.approved = object.approved ?? false;
    switch (object.verdict?.$case) {
      case "fulfilmentVerdict": {
        if (
          object.verdict?.value !== undefined &&
          object.verdict?.value !== null
        ) {
          message.verdict = {
            $case: "fulfilmentVerdict",
            value: FulfilmentVerdict.fromPartial(object.verdict.value),
          };
        }
        break;
      }
      case "refundVerdict": {
        if (
          object.verdict?.value !== undefined &&
          object.verdict?.value !== null
        ) {
          message.verdict = {
            $case: "refundVerdict",
            value: RefundVerdict.fromPartial(object.verdict.value),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseChainParams(): ChainParams {
  return {
    chainID: new Uint8Array(0),
    allTokensDisabled: false,
    disabledTokens: [],
  };
}

export const ChainParams: MessageFns<ChainParams> = {
  encode(
    message: ChainParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainID.length !== 0) {
      writer.uint32(10).bytes(message.chainID);
    }
    if (message.allTokensDisabled !== false) {
      writer.uint32(16).bool(message.allTokensDisabled);
    }
    for (const v of message.disabledTokens) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allTokensDisabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.disabledTokens.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainParams {
    return {
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      allTokensDisabled: isSet(object.allTokensDisabled)
        ? globalThis.Boolean(object.allTokensDisabled)
        : false,
      disabledTokens: globalThis.Array.isArray(object?.disabledTokens)
        ? object.disabledTokens.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ChainParams): unknown {
    const obj: any = {};
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.allTokensDisabled !== false) {
      obj.allTokensDisabled = message.allTokensDisabled;
    }
    if (message.disabledTokens?.length) {
      obj.disabledTokens = message.disabledTokens.map((e) =>
        base64FromBytes(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainParams>, I>>(base?: I): ChainParams {
    return ChainParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainParams>, I>>(
    object: I,
  ): ChainParams {
    const message = createBaseChainParams();
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.allTokensDisabled = object.allTokensDisabled ?? false;
    message.disabledTokens = object.disabledTokens?.map((e) => e) || [];
    return message;
  },
};

function createBaseUniverseParams(): UniverseParams {
  return { universe: 0, allChainsDisabled: false, chainParams: [] };
}

export const UniverseParams: MessageFns<UniverseParams> = {
  encode(
    message: UniverseParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.allChainsDisabled !== false) {
      writer.uint32(16).bool(message.allChainsDisabled);
    }
    for (const v of message.chainParams) {
      ChainParams.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UniverseParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUniverseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allChainsDisabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainParams.push(ChainParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UniverseParams {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      allChainsDisabled: isSet(object.allChainsDisabled)
        ? globalThis.Boolean(object.allChainsDisabled)
        : false,
      chainParams: globalThis.Array.isArray(object?.chainParams)
        ? object.chainParams.map((e: any) => ChainParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UniverseParams): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.allChainsDisabled !== false) {
      obj.allChainsDisabled = message.allChainsDisabled;
    }
    if (message.chainParams?.length) {
      obj.chainParams = message.chainParams.map((e) => ChainParams.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UniverseParams>, I>>(
    base?: I,
  ): UniverseParams {
    return UniverseParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UniverseParams>, I>>(
    object: I,
  ): UniverseParams {
    const message = createBaseUniverseParams();
    message.universe = object.universe ?? 0;
    message.allChainsDisabled = object.allChainsDisabled ?? false;
    message.chainParams =
      object.chainParams?.map((e) => ChainParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParams(): Params {
  return {
    mpcAddress: new Uint8Array(0),
    maxAttempts: 0,
    settlementNo: 0,
    newRFFDisabled: false,
    universeParams: [],
  };
}

export const Params: MessageFns<Params> = {
  encode(
    message: Params,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mpcAddress.length !== 0) {
      writer.uint32(10).bytes(message.mpcAddress);
    }
    if (message.maxAttempts !== 0) {
      writer.uint32(16).uint32(message.maxAttempts);
    }
    if (message.settlementNo !== 0) {
      writer.uint32(24).uint32(message.settlementNo);
    }
    if (message.newRFFDisabled !== false) {
      writer.uint32(80).bool(message.newRFFDisabled);
    }
    for (const v of message.universeParams) {
      UniverseParams.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mpcAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxAttempts = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.settlementNo = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.newRFFDisabled = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.universeParams.push(
            UniverseParams.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      mpcAddress: isSet(object.mpcAddress)
        ? bytesFromBase64(object.mpcAddress)
        : new Uint8Array(0),
      maxAttempts: isSet(object.maxAttempts)
        ? globalThis.Number(object.maxAttempts)
        : 0,
      settlementNo: isSet(object.settlementNo)
        ? globalThis.Number(object.settlementNo)
        : 0,
      newRFFDisabled: isSet(object.newRFFDisabled)
        ? globalThis.Boolean(object.newRFFDisabled)
        : false,
      universeParams: globalThis.Array.isArray(object?.universeParams)
        ? object.universeParams.map((e: any) => UniverseParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.mpcAddress.length !== 0) {
      obj.mpcAddress = base64FromBytes(message.mpcAddress);
    }
    if (message.maxAttempts !== 0) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.settlementNo !== 0) {
      obj.settlementNo = Math.round(message.settlementNo);
    }
    if (message.newRFFDisabled !== false) {
      obj.newRFFDisabled = message.newRFFDisabled;
    }
    if (message.universeParams?.length) {
      obj.universeParams = message.universeParams.map((e) =>
        UniverseParams.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.mpcAddress = object.mpcAddress ?? new Uint8Array(0);
    message.maxAttempts = object.maxAttempts ?? 0;
    message.settlementNo = object.settlementNo ?? 0;
    message.newRFFDisabled = object.newRFFDisabled ?? false;
    message.universeParams =
      object.universeParams?.map((e) => UniverseParams.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends { $case: string; value: unknown }
          ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
          : T extends {}
            ? { [K in keyof T]?: DeepPartial<T[K]> }
            : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
