// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.33.1
// source: definition.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "";

export enum RFFSourceState {
  WAITING = 0,
  DEPOSITED = 1,
  UNRECOGNIZED = -1,
}

export function rFFSourceStateFromJSON(object: any): RFFSourceState {
  switch (object) {
    case 0:
    case "WAITING":
      return RFFSourceState.WAITING;
    case 1:
    case "DEPOSITED":
      return RFFSourceState.DEPOSITED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RFFSourceState.UNRECOGNIZED;
  }
}

export function rFFSourceStateToJSON(object: RFFSourceState): string {
  switch (object) {
    case RFFSourceState.WAITING:
      return "WAITING";
    case RFFSourceState.DEPOSITED:
      return "DEPOSITED";
    case RFFSourceState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Universe {
  ETHEREUM = 0,
  FUEL = 1,
  SOLANA = 2,
  TRON = 3,
  UNRECOGNIZED = -1,
}

export function universeFromJSON(object: any): Universe {
  switch (object) {
    case 0:
    case "ETHEREUM":
      return Universe.ETHEREUM;
    case 1:
    case "FUEL":
      return Universe.FUEL;
    case 2:
    case "SOLANA":
      return Universe.SOLANA;
    case 3:
    case "TRON":
      return Universe.TRON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Universe.UNRECOGNIZED;
  }
}

export function universeToJSON(object: Universe): string {
  switch (object) {
    case Universe.ETHEREUM:
      return "ETHEREUM";
    case Universe.FUEL:
      return "FUEL";
    case Universe.SOLANA:
      return "SOLANA";
    case Universe.TRON:
      return "TRON";
    case Universe.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
  /**
   * key is a value returned in PageResponse.next_key to begin
   * querying the next page most efficiently. Only one of offset or key
   * should be set.
   */
  key: Uint8Array;
  /**
   * offset is a numeric offset that can be used when key is unavailable.
   * It is less efficient than using key. Only one of offset or key should
   * be set.
   */
  offset: Long;
  /**
   * limit is the total number of results to be returned in the result page.
   * If left empty it will default to a value to be set by each app.
   */
  limit: Long;
  /**
   * count_total is set to true  to indicate that the result set should include
   * a count of the total number of items available for pagination in UIs.
   * count_total is only respected when offset is used. It is ignored when key
   * is set.
   */
  countTotal: boolean;
  /** reverse is set to true if results are to be returned in the descending order. */
  reverse: boolean;
}

/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
  /**
   * next_key is the key to be passed to PageRequest.key to
   * query the next page most efficiently. It will be empty if
   * there are no more results.
   */
  nextKey: Uint8Array;
  /**
   * total is total number of results available if PageRequest.count_total
   * was set, its value is undefined otherwise
   */
  total: Long;
}

export interface RFFSourcePair {
  universe: Universe;
  chainID: Uint8Array;
  contractAddress: Uint8Array;
  value: Uint8Array;
  status: RFFSourceState;
}

export interface SignatureDatum {
  universe: Universe;
  address: Uint8Array;
  /** WARNING: This is NOT validated by Cosmos any more */
  signature: Uint8Array;
  /** is to be left empty by the creator and is to be filled in during signature verification */
  hash: Uint8Array;
}

export interface RFFDestinationPair {
  contractAddress: Uint8Array;
  /** amount */
  value: Uint8Array;
}

export interface RequestForFunds {
  id: Long;
  sources: RFFSourcePair[];
  destinationUniverse: Universe;
  destinationChainID: Uint8Array;
  recipientAddress: Uint8Array;
  destinations: RFFDestinationPair[];
  nonce: Uint8Array;
  expiry: Long;
  signatureData: SignatureDatum[];
  /** Cosmos user (???)/Cosmos internal fields */
  user: string;
  /** the EVM address that fulfilled it on the destination chain */
  fulfilledBy: Uint8Array;
  fulfilledAt: Long;
  deposited: boolean;
  fulfilled: boolean;
  settled: boolean;
  refunded: boolean;
  creationBlock: Long;
}

export interface RFFCreatedEvent {
  id: Long;
}

export interface RFFAllDepositsCompleteEvent {
  id: Long;
}

export interface RFFFulfilledEvent {
  id: Long;
}

export interface RouteFee {
  sourceUniverse: Universe;
  destinationUniverse: Universe;
  sourceChainID: Uint8Array;
  destinationChainID: Uint8Array;
  sourceTokenAddress: Uint8Array;
  destinationTokenAddress: Uint8Array;
  /** 7 â†” 9 are reserved for new fields */
  feeBP: number;
}

export interface SolverAddress {
  universe: Universe;
  address: Uint8Array;
  signature: Uint8Array;
}

export interface SolverData {
  cosmosAddress: string;
  advertisedFees: RouteFee[];
  addresses: SolverAddress[];
}

/** Settlement defines the Settlement message. */
export interface Settlement {
  id: Uint8Array;
  universe: Universe;
  chainID: Uint8Array;
  amounts: Uint8Array[];
  contractAddresses: Uint8Array[];
  solvers: Uint8Array[];
}

export interface FixedFeeTuple {
  universe: Universe;
  chainID: Uint8Array;
  tokenAddress: Uint8Array;
  fee: Uint8Array;
}

export interface AdminFeeRecipient {
  universe: Universe;
  address: Uint8Array;
}

export interface ProtocolFees {
  feeBP: Long;
  collectionFees: FixedFeeTuple[];
  fulfilmentFees: FixedFeeTuple[];
  admin: string;
  feeRecipients: AdminFeeRecipient[];
}

export interface PendingSettlement {
  id: Long;
  universe: Universe;
  chainID: Uint8Array;
  contractAddress: Uint8Array;
  amount: Uint8Array;
  recipient: Uint8Array;
}

export interface FulfilmentClaim {}

export interface RefundClaim {}

export interface BasicClaim {
  RFFID: Long;
  claim?:
    | { $case: "fulfilmentClaim"; value: FulfilmentClaim }
    | { $case: "refundClaim"; value: RefundClaim }
    | undefined;
}

/** PendingClaims defines the PendingClaims message. */
export interface PendingClaims {
  id: Long;
  creator: string;
  claim?: BasicClaim | undefined;
  timestamp: Long;
  attempts: number;
}

export interface FulfilmentVerdict {
  depositedIndexes: number[];
  solverAddress: Uint8Array;
}

export interface RefundVerdict {
  depositedIndexes: number[];
}

export interface ClaimVerdict {
  approved: boolean;
  verdict?:
    | { $case: "fulfilmentVerdict"; value: FulfilmentVerdict }
    | { $case: "refundVerdict"; value: RefundVerdict }
    | undefined;
}

export interface ChainParams {
  chainID: Uint8Array;
  allTokensDisabled: boolean;
  disabledTokens: Uint8Array[];
}

export interface UniverseParams {
  universe: Universe;
  allChainsDisabled: boolean;
  chainParams: ChainParams[];
}

/** Params defines the parameters for the module. */
export interface Params {
  mpcAddress: Uint8Array;
  maxAttempts: number;
  settlementNo: number;
  newRFFDisabled: boolean;
  universeParams: UniverseParams[];
}

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params?: Params | undefined;
}

/** QueryGetRequestForFundsRequest defines the QueryGetRequestForFundsRequest message. */
export interface QueryGetRequestForFundsRequest {
  id: Long;
}

/** QueryGetRequestForFundsResponse defines the QueryGetRequestForFundsResponse message. */
export interface QueryGetRequestForFundsResponse {
  requestForFunds?: RequestForFunds | undefined;
}

/** QueryAllRequestForFundsRequest defines the QueryAllRequestForFundsRequest message. */
export interface QueryAllRequestForFundsRequest {
  pagination?: PageRequest | undefined;
}

/** QueryAllRequestForFundsResponse defines the QueryAllRequestForFundsResponse message. */
export interface QueryAllRequestForFundsResponse {
  requestForFunds: RequestForFunds[];
  pagination?: PageResponse | undefined;
}

/** QueryGetPendingClaimsRequest defines the QueryGetPendingClaimsRequest message. */
export interface QueryGetPendingClaimsRequest {
  id: Long;
}

/** QueryGetPendingClaimsResponse defines the QueryGetPendingClaimsResponse message. */
export interface QueryGetPendingClaimsResponse {
  pendingClaims?: PendingClaims | undefined;
}

/** QueryAllPendingClaimsRequest defines the QueryAllPendingClaimsRequest message. */
export interface QueryAllPendingClaimsRequest {
  pagination?: PageRequest | undefined;
}

/** QueryAllPendingClaimsResponse defines the QueryAllPendingClaimsResponse message. */
export interface QueryAllPendingClaimsResponse {
  pendingClaims: PendingClaims[];
  pagination?: PageResponse | undefined;
}

/** QueryGetPendingSettlementsRequest defines the QueryGetPendingSettlementsRequest message. */
export interface QueryGetPendingSettlementsRequest {
  id: Long;
}

/** QueryGetPendingSettlementsResponse defines the QueryGetPendingSettlementsResponse message. */
export interface QueryGetPendingSettlementsResponse {
  pendingSettlements?: PendingSettlement | undefined;
}

/** QueryAllPendingSettlementsRequest defines the QueryAllPendingSettlementsRequest message. */
export interface QueryAllPendingSettlementsRequest {
  pagination?: PageRequest | undefined;
}

/** QueryAllPendingSettlementsResponse defines the QueryAllPendingSettlementsResponse message. */
export interface QueryAllPendingSettlementsResponse {
  pendingSettlements: PendingSettlement[];
  pagination?: PageResponse | undefined;
}

/** QueryGetProtocolFeesRequest defines the QueryGetProtocolFeesRequest message. */
export interface QueryGetProtocolFeesRequest {}

/** QueryGetProtocolFeesResponse defines the QueryGetProtocolFeesResponse message. */
export interface QueryGetProtocolFeesResponse {
  protocolFees?: ProtocolFees | undefined;
}

/** QueryGetSolverDataRequest defines the QueryGetSolverDataRequest message. */
export interface QueryGetSolverDataRequest {
  index: string;
}

/** QueryGetSolverDataResponse defines the QueryGetSolverDataResponse message. */
export interface QueryGetSolverDataResponse {
  solverData?: SolverData | undefined;
}

/** QueryAllSolverDataRequest defines the QueryAllSolverDataRequest message. */
export interface QueryAllSolverDataRequest {
  pagination?: PageRequest | undefined;
}

/** QueryAllSolverDataResponse defines the QueryAllSolverDataResponse message. */
export interface QueryAllSolverDataResponse {
  solverData: SolverData[];
  pagination?: PageResponse | undefined;
}

/** QueryGetSettlementRequest defines the QueryGetSettlementRequest message. */
export interface QueryGetSettlementRequest {
  id: Long;
}

/** QueryGetSettlementResponse defines the QueryGetSettlementResponse message. */
export interface QueryGetSettlementResponse {
  settlement?: Settlement | undefined;
}

/** QueryAllSettlementRequest defines the QueryAllSettlementRequest message. */
export interface QueryAllSettlementRequest {
  pagination?: PageRequest | undefined;
}

/** QueryAllSettlementResponse defines the QueryAllSettlementResponse message. */
export interface QueryAllSettlementResponse {
  settlement: Settlement[];
  pagination?: PageResponse | undefined;
}

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /** NOTE: All parameters must be supplied. */
  params?: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {}

/** MsgCreateRequestForFunds defines the MsgCreateRequestForFunds message. */
export interface MsgCreateRequestForFunds {
  user: string;
  sources: RFFSourcePair[];
  destinationUniverse: Universe;
  destinationChainID: Uint8Array;
  recipientAddress: Uint8Array;
  destinations: RFFDestinationPair[];
  nonce: Uint8Array;
  expiry: Long;
  signatureData: SignatureDatum[];
}

/** MsgCreateRequestForFundsResponse defines the MsgCreateRequestForFundsResponse message. */
export interface MsgCreateRequestForFundsResponse {
  id: Long;
}

/** MsgCreatePendingClaims defines the MsgCreatePendingClaims message. */
export interface MsgCreatePendingClaim {
  creator: string;
  claim?: BasicClaim | undefined;
}

/** MsgCreatePendingClaimsResponse defines the MsgCreatePendingClaimsResponse message. */
export interface MsgCreatePendingClaimResponse {
  id: Long;
}

/** MsgUpdatePendingClaims defines the MsgUpdatePendingClaims message. */
export interface MsgProcessPendingClaim {
  creator: string;
  claimId: Long;
  verdict?: ClaimVerdict | undefined;
  signature: Uint8Array;
}

/** MsgUpdatePendingClaimsResponse defines the MsgUpdatePendingClaimsResponse message. */
export interface MsgProcessPendingClaimResponse {}

/** MsgUpsertProtocolFees defines the MsgUpsertProtocolFees message. */
export interface MsgUpsertProtocolFees {
  creator: string;
  feeBP: Long;
  collectionFees: FixedFeeTuple[];
  fulfilmentFees: FixedFeeTuple[];
  feeRecipients: AdminFeeRecipient[];
}

/** MsgUpsertProtocolFeesResponse defines the MsgUpsertProtocolFeesResponse message. */
export interface MsgUpsertProtocolFeesResponse {}

/** MsgCreateSolverData defines the MsgCreateSolverData message. */
export interface MsgUpsertSolverData {
  cosmosAddress: string;
  advertisedFees: RouteFee[];
  addresses: SolverAddress[];
}

/** MsgCreateSolverDataResponse defines the MsgCreateSolverDataResponse message. */
export interface MsgUpsertSolverDataResponse {}

function createBasePageRequest(): PageRequest {
  return {
    key: new Uint8Array(0),
    offset: Long.UZERO,
    limit: Long.UZERO,
    countTotal: false,
    reverse: false,
  };
}

export const PageRequest: MessageFns<PageRequest> = {
  encode(
    message: PageRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (!message.offset.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.offset.toString());
    }
    if (!message.limit.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.limit.toString());
    }
    if (message.countTotal !== false) {
      writer.uint32(32).bool(message.countTotal);
    }
    if (message.reverse !== false) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.countTotal = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reverse = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageRequest {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.UZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.UZERO,
      countTotal: isSet(object.countTotal)
        ? globalThis.Boolean(object.countTotal)
        : false,
      reverse: isSet(object.reverse)
        ? globalThis.Boolean(object.reverse)
        : false,
    };
  },

  toJSON(message: PageRequest): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (!message.offset.equals(Long.UZERO)) {
      obj.offset = (message.offset || Long.UZERO).toString();
    }
    if (!message.limit.equals(Long.UZERO)) {
      obj.limit = (message.limit || Long.UZERO).toString();
    }
    if (message.countTotal !== false) {
      obj.countTotal = message.countTotal;
    }
    if (message.reverse !== false) {
      obj.reverse = message.reverse;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PageRequest>, I>>(base?: I): PageRequest {
    return PageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PageRequest>, I>>(
    object: I,
  ): PageRequest {
    const message = createBasePageRequest();
    message.key = object.key ?? new Uint8Array(0);
    message.offset =
      object.offset !== undefined && object.offset !== null
        ? Long.fromValue(object.offset)
        : Long.UZERO;
    message.limit =
      object.limit !== undefined && object.limit !== null
        ? Long.fromValue(object.limit)
        : Long.UZERO;
    message.countTotal = object.countTotal ?? false;
    message.reverse = object.reverse ?? false;
    return message;
  },
};

function createBasePageResponse(): PageResponse {
  return { nextKey: new Uint8Array(0), total: Long.UZERO };
}

export const PageResponse: MessageFns<PageResponse> = {
  encode(
    message: PageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nextKey.length !== 0) {
      writer.uint32(10).bytes(message.nextKey);
    }
    if (!message.total.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.total.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nextKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageResponse {
    return {
      nextKey: isSet(object.nextKey)
        ? bytesFromBase64(object.nextKey)
        : new Uint8Array(0),
      total: isSet(object.total) ? Long.fromValue(object.total) : Long.UZERO,
    };
  },

  toJSON(message: PageResponse): unknown {
    const obj: any = {};
    if (message.nextKey.length !== 0) {
      obj.nextKey = base64FromBytes(message.nextKey);
    }
    if (!message.total.equals(Long.UZERO)) {
      obj.total = (message.total || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PageResponse>, I>>(
    base?: I,
  ): PageResponse {
    return PageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PageResponse>, I>>(
    object: I,
  ): PageResponse {
    const message = createBasePageResponse();
    message.nextKey = object.nextKey ?? new Uint8Array(0);
    message.total =
      object.total !== undefined && object.total !== null
        ? Long.fromValue(object.total)
        : Long.UZERO;
    return message;
  },
};

function createBaseRFFSourcePair(): RFFSourcePair {
  return {
    universe: 0,
    chainID: new Uint8Array(0),
    contractAddress: new Uint8Array(0),
    value: new Uint8Array(0),
    status: 0,
  };
}

export const RFFSourcePair: MessageFns<RFFSourcePair> = {
  encode(
    message: RFFSourcePair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(18).bytes(message.chainID);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(26).bytes(message.contractAddress);
    }
    if (message.value.length !== 0) {
      writer.uint32(34).bytes(message.value);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RFFSourcePair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFSourcePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFSourcePair {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      contractAddress: isSet(object.contractAddress)
        ? bytesFromBase64(object.contractAddress)
        : new Uint8Array(0),
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
      status: isSet(object.status) ? rFFSourceStateFromJSON(object.status) : 0,
    };
  },

  toJSON(message: RFFSourcePair): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.status !== 0) {
      obj.status = rFFSourceStateToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFSourcePair>, I>>(
    base?: I,
  ): RFFSourcePair {
    return RFFSourcePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFSourcePair>, I>>(
    object: I,
  ): RFFSourcePair {
    const message = createBaseRFFSourcePair();
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.contractAddress = object.contractAddress ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseSignatureDatum(): SignatureDatum {
  return {
    universe: 0,
    address: new Uint8Array(0),
    signature: new Uint8Array(0),
    hash: new Uint8Array(0),
  };
}

export const SignatureDatum: MessageFns<SignatureDatum> = {
  encode(
    message: SignatureDatum,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    if (message.hash.length !== 0) {
      writer.uint32(34).bytes(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureDatum {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureDatum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureDatum {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
      hash: isSet(object.hash)
        ? bytesFromBase64(object.hash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SignatureDatum): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignatureDatum>, I>>(
    base?: I,
  ): SignatureDatum {
    return SignatureDatum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignatureDatum>, I>>(
    object: I,
  ): SignatureDatum {
    const message = createBaseSignatureDatum();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.hash = object.hash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRFFDestinationPair(): RFFDestinationPair {
  return { contractAddress: new Uint8Array(0), value: new Uint8Array(0) };
}

export const RFFDestinationPair: MessageFns<RFFDestinationPair> = {
  encode(
    message: RFFDestinationPair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.contractAddress.length !== 0) {
      writer.uint32(10).bytes(message.contractAddress);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RFFDestinationPair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFDestinationPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFDestinationPair {
    return {
      contractAddress: isSet(object.contractAddress)
        ? bytesFromBase64(object.contractAddress)
        : new Uint8Array(0),
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
    };
  },

  toJSON(message: RFFDestinationPair): unknown {
    const obj: any = {};
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFDestinationPair>, I>>(
    base?: I,
  ): RFFDestinationPair {
    return RFFDestinationPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFDestinationPair>, I>>(
    object: I,
  ): RFFDestinationPair {
    const message = createBaseRFFDestinationPair();
    message.contractAddress = object.contractAddress ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestForFunds(): RequestForFunds {
  return {
    id: Long.UZERO,
    sources: [],
    destinationUniverse: 0,
    destinationChainID: new Uint8Array(0),
    recipientAddress: new Uint8Array(0),
    destinations: [],
    nonce: new Uint8Array(0),
    expiry: Long.UZERO,
    signatureData: [],
    user: "",
    fulfilledBy: new Uint8Array(0),
    fulfilledAt: Long.UZERO,
    deposited: false,
    fulfilled: false,
    settled: false,
    refunded: false,
    creationBlock: Long.ZERO,
  };
}

export const RequestForFunds: MessageFns<RequestForFunds> = {
  encode(
    message: RequestForFunds,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    for (const v of message.sources) {
      RFFSourcePair.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.destinationUniverse !== 0) {
      writer.uint32(72).int32(message.destinationUniverse);
    }
    if (message.destinationChainID.length !== 0) {
      writer.uint32(26).bytes(message.destinationChainID);
    }
    if (message.recipientAddress.length !== 0) {
      writer.uint32(90).bytes(message.recipientAddress);
    }
    for (const v of message.destinations) {
      RFFDestinationPair.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.expiry.toString());
    }
    for (const v of message.signatureData) {
      SignatureDatum.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.user !== "") {
      writer.uint32(810).string(message.user);
    }
    if (message.fulfilledBy.length !== 0) {
      writer.uint32(818).bytes(message.fulfilledBy);
    }
    if (!message.fulfilledAt.equals(Long.UZERO)) {
      writer.uint32(824).uint64(message.fulfilledAt.toString());
    }
    if (message.deposited !== false) {
      writer.uint32(832).bool(message.deposited);
    }
    if (message.fulfilled !== false) {
      writer.uint32(840).bool(message.fulfilled);
    }
    if (message.settled !== false) {
      writer.uint32(848).bool(message.settled);
    }
    if (message.refunded !== false) {
      writer.uint32(856).bool(message.refunded);
    }
    if (!message.creationBlock.equals(Long.ZERO)) {
      writer.uint32(872).int64(message.creationBlock.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestForFunds {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestForFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sources.push(RFFSourcePair.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.destinationUniverse = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationChainID = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.recipientAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinations.push(
            RFFDestinationPair.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiry = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.signatureData.push(
            SignatureDatum.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.fulfilledBy = reader.bytes();
          continue;
        }
        case 103: {
          if (tag !== 824) {
            break;
          }

          message.fulfilledAt = Long.fromString(
            reader.uint64().toString(),
            true,
          );
          continue;
        }
        case 104: {
          if (tag !== 832) {
            break;
          }

          message.deposited = reader.bool();
          continue;
        }
        case 105: {
          if (tag !== 840) {
            break;
          }

          message.fulfilled = reader.bool();
          continue;
        }
        case 106: {
          if (tag !== 848) {
            break;
          }

          message.settled = reader.bool();
          continue;
        }
        case 107: {
          if (tag !== 856) {
            break;
          }

          message.refunded = reader.bool();
          continue;
        }
        case 109: {
          if (tag !== 872) {
            break;
          }

          message.creationBlock = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestForFunds {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => RFFSourcePair.fromJSON(e))
        : [],
      destinationUniverse: isSet(object.destinationUniverse)
        ? universeFromJSON(object.destinationUniverse)
        : 0,
      destinationChainID: isSet(object.destinationChainID)
        ? bytesFromBase64(object.destinationChainID)
        : new Uint8Array(0),
      recipientAddress: isSet(object.recipientAddress)
        ? bytesFromBase64(object.recipientAddress)
        : new Uint8Array(0),
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => RFFDestinationPair.fromJSON(e))
        : [],
      nonce: isSet(object.nonce)
        ? bytesFromBase64(object.nonce)
        : new Uint8Array(0),
      expiry: isSet(object.expiry) ? Long.fromValue(object.expiry) : Long.UZERO,
      signatureData: globalThis.Array.isArray(object?.signatureData)
        ? object.signatureData.map((e: any) => SignatureDatum.fromJSON(e))
        : [],
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      fulfilledBy: isSet(object.fulfilledBy)
        ? bytesFromBase64(object.fulfilledBy)
        : new Uint8Array(0),
      fulfilledAt: isSet(object.fulfilledAt)
        ? Long.fromValue(object.fulfilledAt)
        : Long.UZERO,
      deposited: isSet(object.deposited)
        ? globalThis.Boolean(object.deposited)
        : false,
      fulfilled: isSet(object.fulfilled)
        ? globalThis.Boolean(object.fulfilled)
        : false,
      settled: isSet(object.settled)
        ? globalThis.Boolean(object.settled)
        : false,
      refunded: isSet(object.refunded)
        ? globalThis.Boolean(object.refunded)
        : false,
      creationBlock: isSet(object.creationBlock)
        ? Long.fromValue(object.creationBlock)
        : Long.ZERO,
    };
  },

  toJSON(message: RequestForFunds): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => RFFSourcePair.toJSON(e));
    }
    if (message.destinationUniverse !== 0) {
      obj.destinationUniverse = universeToJSON(message.destinationUniverse);
    }
    if (message.destinationChainID.length !== 0) {
      obj.destinationChainID = base64FromBytes(message.destinationChainID);
    }
    if (message.recipientAddress.length !== 0) {
      obj.recipientAddress = base64FromBytes(message.recipientAddress);
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) =>
        RFFDestinationPair.toJSON(e),
      );
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      obj.expiry = (message.expiry || Long.UZERO).toString();
    }
    if (message.signatureData?.length) {
      obj.signatureData = message.signatureData.map((e) =>
        SignatureDatum.toJSON(e),
      );
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.fulfilledBy.length !== 0) {
      obj.fulfilledBy = base64FromBytes(message.fulfilledBy);
    }
    if (!message.fulfilledAt.equals(Long.UZERO)) {
      obj.fulfilledAt = (message.fulfilledAt || Long.UZERO).toString();
    }
    if (message.deposited !== false) {
      obj.deposited = message.deposited;
    }
    if (message.fulfilled !== false) {
      obj.fulfilled = message.fulfilled;
    }
    if (message.settled !== false) {
      obj.settled = message.settled;
    }
    if (message.refunded !== false) {
      obj.refunded = message.refunded;
    }
    if (!message.creationBlock.equals(Long.ZERO)) {
      obj.creationBlock = (message.creationBlock || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestForFunds>, I>>(
    base?: I,
  ): RequestForFunds {
    return RequestForFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestForFunds>, I>>(
    object: I,
  ): RequestForFunds {
    const message = createBaseRequestForFunds();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.sources =
      object.sources?.map((e) => RFFSourcePair.fromPartial(e)) || [];
    message.destinationUniverse = object.destinationUniverse ?? 0;
    message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
    message.recipientAddress = object.recipientAddress ?? new Uint8Array(0);
    message.destinations =
      object.destinations?.map((e) => RFFDestinationPair.fromPartial(e)) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.expiry =
      object.expiry !== undefined && object.expiry !== null
        ? Long.fromValue(object.expiry)
        : Long.UZERO;
    message.signatureData =
      object.signatureData?.map((e) => SignatureDatum.fromPartial(e)) || [];
    message.user = object.user ?? "";
    message.fulfilledBy = object.fulfilledBy ?? new Uint8Array(0);
    message.fulfilledAt =
      object.fulfilledAt !== undefined && object.fulfilledAt !== null
        ? Long.fromValue(object.fulfilledAt)
        : Long.UZERO;
    message.deposited = object.deposited ?? false;
    message.fulfilled = object.fulfilled ?? false;
    message.settled = object.settled ?? false;
    message.refunded = object.refunded ?? false;
    message.creationBlock =
      object.creationBlock !== undefined && object.creationBlock !== null
        ? Long.fromValue(object.creationBlock)
        : Long.ZERO;
    return message;
  },
};

function createBaseRFFCreatedEvent(): RFFCreatedEvent {
  return { id: Long.UZERO };
}

export const RFFCreatedEvent: MessageFns<RFFCreatedEvent> = {
  encode(
    message: RFFCreatedEvent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RFFCreatedEvent {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFCreatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFCreatedEvent {
    return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
  },

  toJSON(message: RFFCreatedEvent): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFCreatedEvent>, I>>(
    base?: I,
  ): RFFCreatedEvent {
    return RFFCreatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFCreatedEvent>, I>>(
    object: I,
  ): RFFCreatedEvent {
    const message = createBaseRFFCreatedEvent();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    return message;
  },
};

function createBaseRFFAllDepositsCompleteEvent(): RFFAllDepositsCompleteEvent {
  return { id: Long.UZERO };
}

export const RFFAllDepositsCompleteEvent: MessageFns<RFFAllDepositsCompleteEvent> =
  {
    encode(
      message: RFFAllDepositsCompleteEvent,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): RFFAllDepositsCompleteEvent {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRFFAllDepositsCompleteEvent();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): RFFAllDepositsCompleteEvent {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: RFFAllDepositsCompleteEvent): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<RFFAllDepositsCompleteEvent>, I>>(
      base?: I,
    ): RFFAllDepositsCompleteEvent {
      return RFFAllDepositsCompleteEvent.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<RFFAllDepositsCompleteEvent>, I>>(
      object: I,
    ): RFFAllDepositsCompleteEvent {
      const message = createBaseRFFAllDepositsCompleteEvent();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseRFFFulfilledEvent(): RFFFulfilledEvent {
  return { id: Long.UZERO };
}

export const RFFFulfilledEvent: MessageFns<RFFFulfilledEvent> = {
  encode(
    message: RFFFulfilledEvent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RFFFulfilledEvent {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRFFFulfilledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RFFFulfilledEvent {
    return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
  },

  toJSON(message: RFFFulfilledEvent): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RFFFulfilledEvent>, I>>(
    base?: I,
  ): RFFFulfilledEvent {
    return RFFFulfilledEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RFFFulfilledEvent>, I>>(
    object: I,
  ): RFFFulfilledEvent {
    const message = createBaseRFFFulfilledEvent();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    return message;
  },
};

function createBaseRouteFee(): RouteFee {
  return {
    sourceUniverse: 0,
    destinationUniverse: 0,
    sourceChainID: new Uint8Array(0),
    destinationChainID: new Uint8Array(0),
    sourceTokenAddress: new Uint8Array(0),
    destinationTokenAddress: new Uint8Array(0),
    feeBP: 0,
  };
}

export const RouteFee: MessageFns<RouteFee> = {
  encode(
    message: RouteFee,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceUniverse !== 0) {
      writer.uint32(8).int32(message.sourceUniverse);
    }
    if (message.destinationUniverse !== 0) {
      writer.uint32(16).int32(message.destinationUniverse);
    }
    if (message.sourceChainID.length !== 0) {
      writer.uint32(26).bytes(message.sourceChainID);
    }
    if (message.destinationChainID.length !== 0) {
      writer.uint32(34).bytes(message.destinationChainID);
    }
    if (message.sourceTokenAddress.length !== 0) {
      writer.uint32(42).bytes(message.sourceTokenAddress);
    }
    if (message.destinationTokenAddress.length !== 0) {
      writer.uint32(50).bytes(message.destinationTokenAddress);
    }
    if (message.feeBP !== 0) {
      writer.uint32(80).uint32(message.feeBP);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteFee {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sourceUniverse = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.destinationUniverse = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceChainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinationChainID = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sourceTokenAddress = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destinationTokenAddress = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.feeBP = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteFee {
    return {
      sourceUniverse: isSet(object.sourceUniverse)
        ? universeFromJSON(object.sourceUniverse)
        : 0,
      destinationUniverse: isSet(object.destinationUniverse)
        ? universeFromJSON(object.destinationUniverse)
        : 0,
      sourceChainID: isSet(object.sourceChainID)
        ? bytesFromBase64(object.sourceChainID)
        : new Uint8Array(0),
      destinationChainID: isSet(object.destinationChainID)
        ? bytesFromBase64(object.destinationChainID)
        : new Uint8Array(0),
      sourceTokenAddress: isSet(object.sourceTokenAddress)
        ? bytesFromBase64(object.sourceTokenAddress)
        : new Uint8Array(0),
      destinationTokenAddress: isSet(object.destinationTokenAddress)
        ? bytesFromBase64(object.destinationTokenAddress)
        : new Uint8Array(0),
      feeBP: isSet(object.feeBP) ? globalThis.Number(object.feeBP) : 0,
    };
  },

  toJSON(message: RouteFee): unknown {
    const obj: any = {};
    if (message.sourceUniverse !== 0) {
      obj.sourceUniverse = universeToJSON(message.sourceUniverse);
    }
    if (message.destinationUniverse !== 0) {
      obj.destinationUniverse = universeToJSON(message.destinationUniverse);
    }
    if (message.sourceChainID.length !== 0) {
      obj.sourceChainID = base64FromBytes(message.sourceChainID);
    }
    if (message.destinationChainID.length !== 0) {
      obj.destinationChainID = base64FromBytes(message.destinationChainID);
    }
    if (message.sourceTokenAddress.length !== 0) {
      obj.sourceTokenAddress = base64FromBytes(message.sourceTokenAddress);
    }
    if (message.destinationTokenAddress.length !== 0) {
      obj.destinationTokenAddress = base64FromBytes(
        message.destinationTokenAddress,
      );
    }
    if (message.feeBP !== 0) {
      obj.feeBP = Math.round(message.feeBP);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteFee>, I>>(base?: I): RouteFee {
    return RouteFee.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteFee>, I>>(object: I): RouteFee {
    const message = createBaseRouteFee();
    message.sourceUniverse = object.sourceUniverse ?? 0;
    message.destinationUniverse = object.destinationUniverse ?? 0;
    message.sourceChainID = object.sourceChainID ?? new Uint8Array(0);
    message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
    message.sourceTokenAddress = object.sourceTokenAddress ?? new Uint8Array(0);
    message.destinationTokenAddress =
      object.destinationTokenAddress ?? new Uint8Array(0);
    message.feeBP = object.feeBP ?? 0;
    return message;
  },
};

function createBaseSolverAddress(): SolverAddress {
  return {
    universe: 0,
    address: new Uint8Array(0),
    signature: new Uint8Array(0),
  };
}

export const SolverAddress: MessageFns<SolverAddress> = {
  encode(
    message: SolverAddress,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolverAddress {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolverAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolverAddress {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SolverAddress): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolverAddress>, I>>(
    base?: I,
  ): SolverAddress {
    return SolverAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolverAddress>, I>>(
    object: I,
  ): SolverAddress {
    const message = createBaseSolverAddress();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSolverData(): SolverData {
  return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}

export const SolverData: MessageFns<SolverData> = {
  encode(
    message: SolverData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cosmosAddress !== "") {
      writer.uint32(10).string(message.cosmosAddress);
    }
    for (const v of message.advertisedFees) {
      RouteFee.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.addresses) {
      SolverAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolverData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolverData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cosmosAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.advertisedFees.push(RouteFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(SolverAddress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolverData {
    return {
      cosmosAddress: isSet(object.cosmosAddress)
        ? globalThis.String(object.cosmosAddress)
        : "",
      advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
        ? object.advertisedFees.map((e: any) => RouteFee.fromJSON(e))
        : [],
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => SolverAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SolverData): unknown {
    const obj: any = {};
    if (message.cosmosAddress !== "") {
      obj.cosmosAddress = message.cosmosAddress;
    }
    if (message.advertisedFees?.length) {
      obj.advertisedFees = message.advertisedFees.map((e) =>
        RouteFee.toJSON(e),
      );
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => SolverAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolverData>, I>>(base?: I): SolverData {
    return SolverData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolverData>, I>>(
    object: I,
  ): SolverData {
    const message = createBaseSolverData();
    message.cosmosAddress = object.cosmosAddress ?? "";
    message.advertisedFees =
      object.advertisedFees?.map((e) => RouteFee.fromPartial(e)) || [];
    message.addresses =
      object.addresses?.map((e) => SolverAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSettlement(): Settlement {
  return {
    id: new Uint8Array(0),
    universe: 0,
    chainID: new Uint8Array(0),
    amounts: [],
    contractAddresses: [],
    solvers: [],
  };
}

export const Settlement: MessageFns<Settlement> = {
  encode(
    message: Settlement,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.universe !== 0) {
      writer.uint32(16).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(26).bytes(message.chainID);
    }
    for (const v of message.amounts) {
      writer.uint32(34).bytes(v!);
    }
    for (const v of message.contractAddresses) {
      writer.uint32(42).bytes(v!);
    }
    for (const v of message.solvers) {
      writer.uint32(50).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settlement {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettlement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amounts.push(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractAddresses.push(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.solvers.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settlement {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      amounts: globalThis.Array.isArray(object?.amounts)
        ? object.amounts.map((e: any) => bytesFromBase64(e))
        : [],
      contractAddresses: globalThis.Array.isArray(object?.contractAddresses)
        ? object.contractAddresses.map((e: any) => bytesFromBase64(e))
        : [],
      solvers: globalThis.Array.isArray(object?.solvers)
        ? object.solvers.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: Settlement): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.amounts?.length) {
      obj.amounts = message.amounts.map((e) => base64FromBytes(e));
    }
    if (message.contractAddresses?.length) {
      obj.contractAddresses = message.contractAddresses.map((e) =>
        base64FromBytes(e),
      );
    }
    if (message.solvers?.length) {
      obj.solvers = message.solvers.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Settlement>, I>>(base?: I): Settlement {
    return Settlement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Settlement>, I>>(
    object: I,
  ): Settlement {
    const message = createBaseSettlement();
    message.id = object.id ?? new Uint8Array(0);
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.amounts = object.amounts?.map((e) => e) || [];
    message.contractAddresses = object.contractAddresses?.map((e) => e) || [];
    message.solvers = object.solvers?.map((e) => e) || [];
    return message;
  },
};

function createBaseFixedFeeTuple(): FixedFeeTuple {
  return {
    universe: 0,
    chainID: new Uint8Array(0),
    tokenAddress: new Uint8Array(0),
    fee: new Uint8Array(0),
  };
}

export const FixedFeeTuple: MessageFns<FixedFeeTuple> = {
  encode(
    message: FixedFeeTuple,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(18).bytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      writer.uint32(26).bytes(message.tokenAddress);
    }
    if (message.fee.length !== 0) {
      writer.uint32(34).bytes(message.fee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixedFeeTuple {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixedFeeTuple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fee = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixedFeeTuple {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      tokenAddress: isSet(object.tokenAddress)
        ? bytesFromBase64(object.tokenAddress)
        : new Uint8Array(0),
      fee: isSet(object.fee) ? bytesFromBase64(object.fee) : new Uint8Array(0),
    };
  },

  toJSON(message: FixedFeeTuple): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    if (message.fee.length !== 0) {
      obj.fee = base64FromBytes(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FixedFeeTuple>, I>>(
    base?: I,
  ): FixedFeeTuple {
    return FixedFeeTuple.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FixedFeeTuple>, I>>(
    object: I,
  ): FixedFeeTuple {
    const message = createBaseFixedFeeTuple();
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
    message.fee = object.fee ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAdminFeeRecipient(): AdminFeeRecipient {
  return { universe: 0, address: new Uint8Array(0) };
}

export const AdminFeeRecipient: MessageFns<AdminFeeRecipient> = {
  encode(
    message: AdminFeeRecipient,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminFeeRecipient {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminFeeRecipient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminFeeRecipient {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
    };
  },

  toJSON(message: AdminFeeRecipient): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminFeeRecipient>, I>>(
    base?: I,
  ): AdminFeeRecipient {
    return AdminFeeRecipient.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminFeeRecipient>, I>>(
    object: I,
  ): AdminFeeRecipient {
    const message = createBaseAdminFeeRecipient();
    message.universe = object.universe ?? 0;
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProtocolFees(): ProtocolFees {
  return {
    feeBP: Long.UZERO,
    collectionFees: [],
    fulfilmentFees: [],
    admin: "",
    feeRecipients: [],
  };
}

export const ProtocolFees: MessageFns<ProtocolFees> = {
  encode(
    message: ProtocolFees,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.feeBP.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.feeBP.toString());
    }
    for (const v of message.collectionFees) {
      FixedFeeTuple.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.fulfilmentFees) {
      FixedFeeTuple.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.admin !== "") {
      writer.uint32(34).string(message.admin);
    }
    for (const v of message.feeRecipients) {
      AdminFeeRecipient.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtocolFees {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocolFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.feeBP = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collectionFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fulfilmentFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feeRecipients.push(
            AdminFeeRecipient.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtocolFees {
    return {
      feeBP: isSet(object.feeBP) ? Long.fromValue(object.feeBP) : Long.UZERO,
      collectionFees: globalThis.Array.isArray(object?.collectionFees)
        ? object.collectionFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
        ? object.fulfilmentFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
        ? object.feeRecipients.map((e: any) => AdminFeeRecipient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProtocolFees): unknown {
    const obj: any = {};
    if (!message.feeBP.equals(Long.UZERO)) {
      obj.feeBP = (message.feeBP || Long.UZERO).toString();
    }
    if (message.collectionFees?.length) {
      obj.collectionFees = message.collectionFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.fulfilmentFees?.length) {
      obj.fulfilmentFees = message.fulfilmentFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.feeRecipients?.length) {
      obj.feeRecipients = message.feeRecipients.map((e) =>
        AdminFeeRecipient.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtocolFees>, I>>(
    base?: I,
  ): ProtocolFees {
    return ProtocolFees.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtocolFees>, I>>(
    object: I,
  ): ProtocolFees {
    const message = createBaseProtocolFees();
    message.feeBP =
      object.feeBP !== undefined && object.feeBP !== null
        ? Long.fromValue(object.feeBP)
        : Long.UZERO;
    message.collectionFees =
      object.collectionFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.fulfilmentFees =
      object.fulfilmentFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.admin = object.admin ?? "";
    message.feeRecipients =
      object.feeRecipients?.map((e) => AdminFeeRecipient.fromPartial(e)) || [];
    return message;
  },
};

function createBasePendingSettlement(): PendingSettlement {
  return {
    id: Long.UZERO,
    universe: 0,
    chainID: new Uint8Array(0),
    contractAddress: new Uint8Array(0),
    amount: new Uint8Array(0),
    recipient: new Uint8Array(0),
  };
}

export const PendingSettlement: MessageFns<PendingSettlement> = {
  encode(
    message: PendingSettlement,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    if (message.universe !== 0) {
      writer.uint32(16).int32(message.universe);
    }
    if (message.chainID.length !== 0) {
      writer.uint32(26).bytes(message.chainID);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(34).bytes(message.contractAddress);
    }
    if (message.amount.length !== 0) {
      writer.uint32(42).bytes(message.amount);
    }
    if (message.recipient.length !== 0) {
      writer.uint32(50).bytes(message.recipient);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingSettlement {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingSettlement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractAddress = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recipient = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingSettlement {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      contractAddress: isSet(object.contractAddress)
        ? bytesFromBase64(object.contractAddress)
        : new Uint8Array(0),
      amount: isSet(object.amount)
        ? bytesFromBase64(object.amount)
        : new Uint8Array(0),
      recipient: isSet(object.recipient)
        ? bytesFromBase64(object.recipient)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PendingSettlement): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.recipient.length !== 0) {
      obj.recipient = base64FromBytes(message.recipient);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingSettlement>, I>>(
    base?: I,
  ): PendingSettlement {
    return PendingSettlement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingSettlement>, I>>(
    object: I,
  ): PendingSettlement {
    const message = createBasePendingSettlement();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.universe = object.universe ?? 0;
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.contractAddress = object.contractAddress ?? new Uint8Array(0);
    message.amount = object.amount ?? new Uint8Array(0);
    message.recipient = object.recipient ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFulfilmentClaim(): FulfilmentClaim {
  return {};
}

export const FulfilmentClaim: MessageFns<FulfilmentClaim> = {
  encode(
    _: FulfilmentClaim,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfilmentClaim {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfilmentClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FulfilmentClaim {
    return {};
  },

  toJSON(_: FulfilmentClaim): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FulfilmentClaim>, I>>(
    base?: I,
  ): FulfilmentClaim {
    return FulfilmentClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FulfilmentClaim>, I>>(
    _: I,
  ): FulfilmentClaim {
    const message = createBaseFulfilmentClaim();
    return message;
  },
};

function createBaseRefundClaim(): RefundClaim {
  return {};
}

export const RefundClaim: MessageFns<RefundClaim> = {
  encode(
    _: RefundClaim,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundClaim {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RefundClaim {
    return {};
  },

  toJSON(_: RefundClaim): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundClaim>, I>>(base?: I): RefundClaim {
    return RefundClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundClaim>, I>>(_: I): RefundClaim {
    const message = createBaseRefundClaim();
    return message;
  },
};

function createBaseBasicClaim(): BasicClaim {
  return { RFFID: Long.UZERO, claim: undefined };
}

export const BasicClaim: MessageFns<BasicClaim> = {
  encode(
    message: BasicClaim,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.RFFID.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.RFFID.toString());
    }
    switch (message.claim?.$case) {
      case "fulfilmentClaim":
        FulfilmentClaim.encode(
          message.claim.value,
          writer.uint32(18).fork(),
        ).join();
        break;
      case "refundClaim":
        RefundClaim.encode(
          message.claim.value,
          writer.uint32(26).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicClaim {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.RFFID = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claim = {
            $case: "fulfilmentClaim",
            value: FulfilmentClaim.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.claim = {
            $case: "refundClaim",
            value: RefundClaim.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicClaim {
    return {
      RFFID: isSet(object.RFFID) ? Long.fromValue(object.RFFID) : Long.UZERO,
      claim: isSet(object.fulfilmentClaim)
        ? {
            $case: "fulfilmentClaim",
            value: FulfilmentClaim.fromJSON(object.fulfilmentClaim),
          }
        : isSet(object.refundClaim)
          ? {
              $case: "refundClaim",
              value: RefundClaim.fromJSON(object.refundClaim),
            }
          : undefined,
    };
  },

  toJSON(message: BasicClaim): unknown {
    const obj: any = {};
    if (!message.RFFID.equals(Long.UZERO)) {
      obj.RFFID = (message.RFFID || Long.UZERO).toString();
    }
    if (message.claim?.$case === "fulfilmentClaim") {
      obj.fulfilmentClaim = FulfilmentClaim.toJSON(message.claim.value);
    } else if (message.claim?.$case === "refundClaim") {
      obj.refundClaim = RefundClaim.toJSON(message.claim.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasicClaim>, I>>(base?: I): BasicClaim {
    return BasicClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasicClaim>, I>>(
    object: I,
  ): BasicClaim {
    const message = createBaseBasicClaim();
    message.RFFID =
      object.RFFID !== undefined && object.RFFID !== null
        ? Long.fromValue(object.RFFID)
        : Long.UZERO;
    switch (object.claim?.$case) {
      case "fulfilmentClaim": {
        if (object.claim?.value !== undefined && object.claim?.value !== null) {
          message.claim = {
            $case: "fulfilmentClaim",
            value: FulfilmentClaim.fromPartial(object.claim.value),
          };
        }
        break;
      }
      case "refundClaim": {
        if (object.claim?.value !== undefined && object.claim?.value !== null) {
          message.claim = {
            $case: "refundClaim",
            value: RefundClaim.fromPartial(object.claim.value),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBasePendingClaims(): PendingClaims {
  return {
    id: Long.UZERO,
    creator: "",
    claim: undefined,
    timestamp: Long.UZERO,
    attempts: 0,
  };
}

export const PendingClaims: MessageFns<PendingClaims> = {
  encode(
    message: PendingClaims,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id.toString());
    }
    if (message.creator !== "") {
      writer.uint32(18).string(message.creator);
    }
    if (message.claim !== undefined) {
      BasicClaim.encode(message.claim, writer.uint32(26).fork()).join();
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.timestamp.toString());
    }
    if (message.attempts !== 0) {
      writer.uint32(32).uint32(message.attempts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingClaims {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingClaims();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.claim = BasicClaim.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attempts = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingClaims {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      claim: isSet(object.claim)
        ? BasicClaim.fromJSON(object.claim)
        : undefined,
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.UZERO,
      attempts: isSet(object.attempts) ? globalThis.Number(object.attempts) : 0,
    };
  },

  toJSON(message: PendingClaims): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.claim !== undefined) {
      obj.claim = BasicClaim.toJSON(message.claim);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    if (message.attempts !== 0) {
      obj.attempts = Math.round(message.attempts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PendingClaims>, I>>(
    base?: I,
  ): PendingClaims {
    return PendingClaims.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PendingClaims>, I>>(
    object: I,
  ): PendingClaims {
    const message = createBasePendingClaims();
    message.id =
      object.id !== undefined && object.id !== null
        ? Long.fromValue(object.id)
        : Long.UZERO;
    message.creator = object.creator ?? "";
    message.claim =
      object.claim !== undefined && object.claim !== null
        ? BasicClaim.fromPartial(object.claim)
        : undefined;
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.UZERO;
    message.attempts = object.attempts ?? 0;
    return message;
  },
};

function createBaseFulfilmentVerdict(): FulfilmentVerdict {
  return { depositedIndexes: [], solverAddress: new Uint8Array(0) };
}

export const FulfilmentVerdict: MessageFns<FulfilmentVerdict> = {
  encode(
    message: FulfilmentVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.depositedIndexes) {
      writer.uint32(v);
    }
    writer.join();
    if (message.solverAddress.length !== 0) {
      writer.uint32(18).bytes(message.solverAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfilmentVerdict {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfilmentVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.depositedIndexes.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.depositedIndexes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.solverAddress = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfilmentVerdict {
    return {
      depositedIndexes: globalThis.Array.isArray(object?.depositedIndexes)
        ? object.depositedIndexes.map((e: any) => globalThis.Number(e))
        : [],
      solverAddress: isSet(object.solverAddress)
        ? bytesFromBase64(object.solverAddress)
        : new Uint8Array(0),
    };
  },

  toJSON(message: FulfilmentVerdict): unknown {
    const obj: any = {};
    if (message.depositedIndexes?.length) {
      obj.depositedIndexes = message.depositedIndexes.map((e) => Math.round(e));
    }
    if (message.solverAddress.length !== 0) {
      obj.solverAddress = base64FromBytes(message.solverAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FulfilmentVerdict>, I>>(
    base?: I,
  ): FulfilmentVerdict {
    return FulfilmentVerdict.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FulfilmentVerdict>, I>>(
    object: I,
  ): FulfilmentVerdict {
    const message = createBaseFulfilmentVerdict();
    message.depositedIndexes = object.depositedIndexes?.map((e) => e) || [];
    message.solverAddress = object.solverAddress ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRefundVerdict(): RefundVerdict {
  return { depositedIndexes: [] };
}

export const RefundVerdict: MessageFns<RefundVerdict> = {
  encode(
    message: RefundVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.depositedIndexes) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundVerdict {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.depositedIndexes.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.depositedIndexes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundVerdict {
    return {
      depositedIndexes: globalThis.Array.isArray(object?.depositedIndexes)
        ? object.depositedIndexes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: RefundVerdict): unknown {
    const obj: any = {};
    if (message.depositedIndexes?.length) {
      obj.depositedIndexes = message.depositedIndexes.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundVerdict>, I>>(
    base?: I,
  ): RefundVerdict {
    return RefundVerdict.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundVerdict>, I>>(
    object: I,
  ): RefundVerdict {
    const message = createBaseRefundVerdict();
    message.depositedIndexes = object.depositedIndexes?.map((e) => e) || [];
    return message;
  },
};

function createBaseClaimVerdict(): ClaimVerdict {
  return { approved: false, verdict: undefined };
}

export const ClaimVerdict: MessageFns<ClaimVerdict> = {
  encode(
    message: ClaimVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.approved !== false) {
      writer.uint32(8).bool(message.approved);
    }
    switch (message.verdict?.$case) {
      case "fulfilmentVerdict":
        FulfilmentVerdict.encode(
          message.verdict.value,
          writer.uint32(82).fork(),
        ).join();
        break;
      case "refundVerdict":
        RefundVerdict.encode(
          message.verdict.value,
          writer.uint32(90).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimVerdict {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.approved = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.verdict = {
            $case: "fulfilmentVerdict",
            value: FulfilmentVerdict.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.verdict = {
            $case: "refundVerdict",
            value: RefundVerdict.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimVerdict {
    return {
      approved: isSet(object.approved)
        ? globalThis.Boolean(object.approved)
        : false,
      verdict: isSet(object.fulfilmentVerdict)
        ? {
            $case: "fulfilmentVerdict",
            value: FulfilmentVerdict.fromJSON(object.fulfilmentVerdict),
          }
        : isSet(object.refundVerdict)
          ? {
              $case: "refundVerdict",
              value: RefundVerdict.fromJSON(object.refundVerdict),
            }
          : undefined,
    };
  },

  toJSON(message: ClaimVerdict): unknown {
    const obj: any = {};
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    if (message.verdict?.$case === "fulfilmentVerdict") {
      obj.fulfilmentVerdict = FulfilmentVerdict.toJSON(message.verdict.value);
    } else if (message.verdict?.$case === "refundVerdict") {
      obj.refundVerdict = RefundVerdict.toJSON(message.verdict.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimVerdict>, I>>(
    base?: I,
  ): ClaimVerdict {
    return ClaimVerdict.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimVerdict>, I>>(
    object: I,
  ): ClaimVerdict {
    const message = createBaseClaimVerdict();
    message.approved = object.approved ?? false;
    switch (object.verdict?.$case) {
      case "fulfilmentVerdict": {
        if (
          object.verdict?.value !== undefined &&
          object.verdict?.value !== null
        ) {
          message.verdict = {
            $case: "fulfilmentVerdict",
            value: FulfilmentVerdict.fromPartial(object.verdict.value),
          };
        }
        break;
      }
      case "refundVerdict": {
        if (
          object.verdict?.value !== undefined &&
          object.verdict?.value !== null
        ) {
          message.verdict = {
            $case: "refundVerdict",
            value: RefundVerdict.fromPartial(object.verdict.value),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseChainParams(): ChainParams {
  return {
    chainID: new Uint8Array(0),
    allTokensDisabled: false,
    disabledTokens: [],
  };
}

export const ChainParams: MessageFns<ChainParams> = {
  encode(
    message: ChainParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainID.length !== 0) {
      writer.uint32(10).bytes(message.chainID);
    }
    if (message.allTokensDisabled !== false) {
      writer.uint32(16).bool(message.allTokensDisabled);
    }
    for (const v of message.disabledTokens) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allTokensDisabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.disabledTokens.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainParams {
    return {
      chainID: isSet(object.chainID)
        ? bytesFromBase64(object.chainID)
        : new Uint8Array(0),
      allTokensDisabled: isSet(object.allTokensDisabled)
        ? globalThis.Boolean(object.allTokensDisabled)
        : false,
      disabledTokens: globalThis.Array.isArray(object?.disabledTokens)
        ? object.disabledTokens.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ChainParams): unknown {
    const obj: any = {};
    if (message.chainID.length !== 0) {
      obj.chainID = base64FromBytes(message.chainID);
    }
    if (message.allTokensDisabled !== false) {
      obj.allTokensDisabled = message.allTokensDisabled;
    }
    if (message.disabledTokens?.length) {
      obj.disabledTokens = message.disabledTokens.map((e) =>
        base64FromBytes(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainParams>, I>>(base?: I): ChainParams {
    return ChainParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainParams>, I>>(
    object: I,
  ): ChainParams {
    const message = createBaseChainParams();
    message.chainID = object.chainID ?? new Uint8Array(0);
    message.allTokensDisabled = object.allTokensDisabled ?? false;
    message.disabledTokens = object.disabledTokens?.map((e) => e) || [];
    return message;
  },
};

function createBaseUniverseParams(): UniverseParams {
  return { universe: 0, allChainsDisabled: false, chainParams: [] };
}

export const UniverseParams: MessageFns<UniverseParams> = {
  encode(
    message: UniverseParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.universe !== 0) {
      writer.uint32(8).int32(message.universe);
    }
    if (message.allChainsDisabled !== false) {
      writer.uint32(16).bool(message.allChainsDisabled);
    }
    for (const v of message.chainParams) {
      ChainParams.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UniverseParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUniverseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.universe = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allChainsDisabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainParams.push(ChainParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UniverseParams {
    return {
      universe: isSet(object.universe) ? universeFromJSON(object.universe) : 0,
      allChainsDisabled: isSet(object.allChainsDisabled)
        ? globalThis.Boolean(object.allChainsDisabled)
        : false,
      chainParams: globalThis.Array.isArray(object?.chainParams)
        ? object.chainParams.map((e: any) => ChainParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UniverseParams): unknown {
    const obj: any = {};
    if (message.universe !== 0) {
      obj.universe = universeToJSON(message.universe);
    }
    if (message.allChainsDisabled !== false) {
      obj.allChainsDisabled = message.allChainsDisabled;
    }
    if (message.chainParams?.length) {
      obj.chainParams = message.chainParams.map((e) => ChainParams.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UniverseParams>, I>>(
    base?: I,
  ): UniverseParams {
    return UniverseParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UniverseParams>, I>>(
    object: I,
  ): UniverseParams {
    const message = createBaseUniverseParams();
    message.universe = object.universe ?? 0;
    message.allChainsDisabled = object.allChainsDisabled ?? false;
    message.chainParams =
      object.chainParams?.map((e) => ChainParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParams(): Params {
  return {
    mpcAddress: new Uint8Array(0),
    maxAttempts: 0,
    settlementNo: 0,
    newRFFDisabled: false,
    universeParams: [],
  };
}

export const Params: MessageFns<Params> = {
  encode(
    message: Params,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mpcAddress.length !== 0) {
      writer.uint32(10).bytes(message.mpcAddress);
    }
    if (message.maxAttempts !== 0) {
      writer.uint32(16).uint32(message.maxAttempts);
    }
    if (message.settlementNo !== 0) {
      writer.uint32(24).uint32(message.settlementNo);
    }
    if (message.newRFFDisabled !== false) {
      writer.uint32(80).bool(message.newRFFDisabled);
    }
    for (const v of message.universeParams) {
      UniverseParams.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mpcAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxAttempts = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.settlementNo = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.newRFFDisabled = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.universeParams.push(
            UniverseParams.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      mpcAddress: isSet(object.mpcAddress)
        ? bytesFromBase64(object.mpcAddress)
        : new Uint8Array(0),
      maxAttempts: isSet(object.maxAttempts)
        ? globalThis.Number(object.maxAttempts)
        : 0,
      settlementNo: isSet(object.settlementNo)
        ? globalThis.Number(object.settlementNo)
        : 0,
      newRFFDisabled: isSet(object.newRFFDisabled)
        ? globalThis.Boolean(object.newRFFDisabled)
        : false,
      universeParams: globalThis.Array.isArray(object?.universeParams)
        ? object.universeParams.map((e: any) => UniverseParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.mpcAddress.length !== 0) {
      obj.mpcAddress = base64FromBytes(message.mpcAddress);
    }
    if (message.maxAttempts !== 0) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.settlementNo !== 0) {
      obj.settlementNo = Math.round(message.settlementNo);
    }
    if (message.newRFFDisabled !== false) {
      obj.newRFFDisabled = message.newRFFDisabled;
    }
    if (message.universeParams?.length) {
      obj.universeParams = message.universeParams.map((e) =>
        UniverseParams.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.mpcAddress = object.mpcAddress ?? new Uint8Array(0);
    message.maxAttempts = object.maxAttempts ?? 0;
    message.settlementNo = object.settlementNo ?? 0;
    message.newRFFDisabled = object.newRFFDisabled ?? false;
    message.universeParams =
      object.universeParams?.map((e) => UniverseParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(
    _: QueryParamsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    base?: I,
  ): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(
    _: I,
  ): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(
    message: QueryParamsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryParamsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    base?: I,
  ): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(
    object: I,
  ): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseQueryGetRequestForFundsRequest(): QueryGetRequestForFundsRequest {
  return { id: Long.UZERO };
}

export const QueryGetRequestForFundsRequest: MessageFns<QueryGetRequestForFundsRequest> =
  {
    encode(
      message: QueryGetRequestForFundsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetRequestForFundsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetRequestForFundsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetRequestForFundsRequest {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: QueryGetRequestForFundsRequest): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetRequestForFundsRequest>, I>>(
      base?: I,
    ): QueryGetRequestForFundsRequest {
      return QueryGetRequestForFundsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryGetRequestForFundsRequest>, I>,
    >(object: I): QueryGetRequestForFundsRequest {
      const message = createBaseQueryGetRequestForFundsRequest();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseQueryGetRequestForFundsResponse(): QueryGetRequestForFundsResponse {
  return { requestForFunds: undefined };
}

export const QueryGetRequestForFundsResponse: MessageFns<QueryGetRequestForFundsResponse> =
  {
    encode(
      message: QueryGetRequestForFundsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.requestForFunds !== undefined) {
        RequestForFunds.encode(
          message.requestForFunds,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetRequestForFundsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetRequestForFundsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.requestForFunds = RequestForFunds.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetRequestForFundsResponse {
      return {
        requestForFunds: isSet(object.requestForFunds)
          ? RequestForFunds.fromJSON(object.requestForFunds)
          : undefined,
      };
    },

    toJSON(message: QueryGetRequestForFundsResponse): unknown {
      const obj: any = {};
      if (message.requestForFunds !== undefined) {
        obj.requestForFunds = RequestForFunds.toJSON(message.requestForFunds);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetRequestForFundsResponse>, I>>(
      base?: I,
    ): QueryGetRequestForFundsResponse {
      return QueryGetRequestForFundsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryGetRequestForFundsResponse>, I>,
    >(object: I): QueryGetRequestForFundsResponse {
      const message = createBaseQueryGetRequestForFundsResponse();
      message.requestForFunds =
        object.requestForFunds !== undefined && object.requestForFunds !== null
          ? RequestForFunds.fromPartial(object.requestForFunds)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllRequestForFundsRequest(): QueryAllRequestForFundsRequest {
  return { pagination: undefined };
}

export const QueryAllRequestForFundsRequest: MessageFns<QueryAllRequestForFundsRequest> =
  {
    encode(
      message: QueryAllRequestForFundsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllRequestForFundsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllRequestForFundsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllRequestForFundsRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllRequestForFundsRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllRequestForFundsRequest>, I>>(
      base?: I,
    ): QueryAllRequestForFundsRequest {
      return QueryAllRequestForFundsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryAllRequestForFundsRequest>, I>,
    >(object: I): QueryAllRequestForFundsRequest {
      const message = createBaseQueryAllRequestForFundsRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllRequestForFundsResponse(): QueryAllRequestForFundsResponse {
  return { requestForFunds: [], pagination: undefined };
}

export const QueryAllRequestForFundsResponse: MessageFns<QueryAllRequestForFundsResponse> =
  {
    encode(
      message: QueryAllRequestForFundsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.requestForFunds) {
        RequestForFunds.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllRequestForFundsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllRequestForFundsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.requestForFunds.push(
              RequestForFunds.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllRequestForFundsResponse {
      return {
        requestForFunds: globalThis.Array.isArray(object?.requestForFunds)
          ? object.requestForFunds.map((e: any) => RequestForFunds.fromJSON(e))
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllRequestForFundsResponse): unknown {
      const obj: any = {};
      if (message.requestForFunds?.length) {
        obj.requestForFunds = message.requestForFunds.map((e) =>
          RequestForFunds.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllRequestForFundsResponse>, I>>(
      base?: I,
    ): QueryAllRequestForFundsResponse {
      return QueryAllRequestForFundsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryAllRequestForFundsResponse>, I>,
    >(object: I): QueryAllRequestForFundsResponse {
      const message = createBaseQueryAllRequestForFundsResponse();
      message.requestForFunds =
        object.requestForFunds?.map((e) => RequestForFunds.fromPartial(e)) ||
        [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryGetPendingClaimsRequest(): QueryGetPendingClaimsRequest {
  return { id: Long.UZERO };
}

export const QueryGetPendingClaimsRequest: MessageFns<QueryGetPendingClaimsRequest> =
  {
    encode(
      message: QueryGetPendingClaimsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetPendingClaimsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetPendingClaimsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetPendingClaimsRequest {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: QueryGetPendingClaimsRequest): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetPendingClaimsRequest>, I>>(
      base?: I,
    ): QueryGetPendingClaimsRequest {
      return QueryGetPendingClaimsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetPendingClaimsRequest>, I>>(
      object: I,
    ): QueryGetPendingClaimsRequest {
      const message = createBaseQueryGetPendingClaimsRequest();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseQueryGetPendingClaimsResponse(): QueryGetPendingClaimsResponse {
  return { pendingClaims: undefined };
}

export const QueryGetPendingClaimsResponse: MessageFns<QueryGetPendingClaimsResponse> =
  {
    encode(
      message: QueryGetPendingClaimsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pendingClaims !== undefined) {
        PendingClaims.encode(
          message.pendingClaims,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetPendingClaimsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetPendingClaimsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pendingClaims = PendingClaims.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetPendingClaimsResponse {
      return {
        pendingClaims: isSet(object.pendingClaims)
          ? PendingClaims.fromJSON(object.pendingClaims)
          : undefined,
      };
    },

    toJSON(message: QueryGetPendingClaimsResponse): unknown {
      const obj: any = {};
      if (message.pendingClaims !== undefined) {
        obj.pendingClaims = PendingClaims.toJSON(message.pendingClaims);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetPendingClaimsResponse>, I>>(
      base?: I,
    ): QueryGetPendingClaimsResponse {
      return QueryGetPendingClaimsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetPendingClaimsResponse>, I>>(
      object: I,
    ): QueryGetPendingClaimsResponse {
      const message = createBaseQueryGetPendingClaimsResponse();
      message.pendingClaims =
        object.pendingClaims !== undefined && object.pendingClaims !== null
          ? PendingClaims.fromPartial(object.pendingClaims)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllPendingClaimsRequest(): QueryAllPendingClaimsRequest {
  return { pagination: undefined };
}

export const QueryAllPendingClaimsRequest: MessageFns<QueryAllPendingClaimsRequest> =
  {
    encode(
      message: QueryAllPendingClaimsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllPendingClaimsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllPendingClaimsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllPendingClaimsRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllPendingClaimsRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllPendingClaimsRequest>, I>>(
      base?: I,
    ): QueryAllPendingClaimsRequest {
      return QueryAllPendingClaimsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllPendingClaimsRequest>, I>>(
      object: I,
    ): QueryAllPendingClaimsRequest {
      const message = createBaseQueryAllPendingClaimsRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllPendingClaimsResponse(): QueryAllPendingClaimsResponse {
  return { pendingClaims: [], pagination: undefined };
}

export const QueryAllPendingClaimsResponse: MessageFns<QueryAllPendingClaimsResponse> =
  {
    encode(
      message: QueryAllPendingClaimsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.pendingClaims) {
        PendingClaims.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllPendingClaimsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllPendingClaimsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pendingClaims.push(
              PendingClaims.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllPendingClaimsResponse {
      return {
        pendingClaims: globalThis.Array.isArray(object?.pendingClaims)
          ? object.pendingClaims.map((e: any) => PendingClaims.fromJSON(e))
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllPendingClaimsResponse): unknown {
      const obj: any = {};
      if (message.pendingClaims?.length) {
        obj.pendingClaims = message.pendingClaims.map((e) =>
          PendingClaims.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllPendingClaimsResponse>, I>>(
      base?: I,
    ): QueryAllPendingClaimsResponse {
      return QueryAllPendingClaimsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllPendingClaimsResponse>, I>>(
      object: I,
    ): QueryAllPendingClaimsResponse {
      const message = createBaseQueryAllPendingClaimsResponse();
      message.pendingClaims =
        object.pendingClaims?.map((e) => PendingClaims.fromPartial(e)) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryGetPendingSettlementsRequest(): QueryGetPendingSettlementsRequest {
  return { id: Long.UZERO };
}

export const QueryGetPendingSettlementsRequest: MessageFns<QueryGetPendingSettlementsRequest> =
  {
    encode(
      message: QueryGetPendingSettlementsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetPendingSettlementsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetPendingSettlementsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetPendingSettlementsRequest {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: QueryGetPendingSettlementsRequest): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetPendingSettlementsRequest>, I>>(
      base?: I,
    ): QueryGetPendingSettlementsRequest {
      return QueryGetPendingSettlementsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryGetPendingSettlementsRequest>, I>,
    >(object: I): QueryGetPendingSettlementsRequest {
      const message = createBaseQueryGetPendingSettlementsRequest();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseQueryGetPendingSettlementsResponse(): QueryGetPendingSettlementsResponse {
  return { pendingSettlements: undefined };
}

export const QueryGetPendingSettlementsResponse: MessageFns<QueryGetPendingSettlementsResponse> =
  {
    encode(
      message: QueryGetPendingSettlementsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pendingSettlements !== undefined) {
        PendingSettlement.encode(
          message.pendingSettlements,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetPendingSettlementsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetPendingSettlementsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pendingSettlements = PendingSettlement.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetPendingSettlementsResponse {
      return {
        pendingSettlements: isSet(object.pendingSettlements)
          ? PendingSettlement.fromJSON(object.pendingSettlements)
          : undefined,
      };
    },

    toJSON(message: QueryGetPendingSettlementsResponse): unknown {
      const obj: any = {};
      if (message.pendingSettlements !== undefined) {
        obj.pendingSettlements = PendingSettlement.toJSON(
          message.pendingSettlements,
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetPendingSettlementsResponse>, I>>(
      base?: I,
    ): QueryGetPendingSettlementsResponse {
      return QueryGetPendingSettlementsResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryGetPendingSettlementsResponse>, I>,
    >(object: I): QueryGetPendingSettlementsResponse {
      const message = createBaseQueryGetPendingSettlementsResponse();
      message.pendingSettlements =
        object.pendingSettlements !== undefined &&
        object.pendingSettlements !== null
          ? PendingSettlement.fromPartial(object.pendingSettlements)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllPendingSettlementsRequest(): QueryAllPendingSettlementsRequest {
  return { pagination: undefined };
}

export const QueryAllPendingSettlementsRequest: MessageFns<QueryAllPendingSettlementsRequest> =
  {
    encode(
      message: QueryAllPendingSettlementsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllPendingSettlementsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllPendingSettlementsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllPendingSettlementsRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllPendingSettlementsRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllPendingSettlementsRequest>, I>>(
      base?: I,
    ): QueryAllPendingSettlementsRequest {
      return QueryAllPendingSettlementsRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryAllPendingSettlementsRequest>, I>,
    >(object: I): QueryAllPendingSettlementsRequest {
      const message = createBaseQueryAllPendingSettlementsRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllPendingSettlementsResponse(): QueryAllPendingSettlementsResponse {
  return { pendingSettlements: [], pagination: undefined };
}

export const QueryAllPendingSettlementsResponse: MessageFns<QueryAllPendingSettlementsResponse> =
  {
    encode(
      message: QueryAllPendingSettlementsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.pendingSettlements) {
        PendingSettlement.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllPendingSettlementsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllPendingSettlementsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pendingSettlements.push(
              PendingSettlement.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllPendingSettlementsResponse {
      return {
        pendingSettlements: globalThis.Array.isArray(object?.pendingSettlements)
          ? object.pendingSettlements.map((e: any) =>
              PendingSettlement.fromJSON(e),
            )
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllPendingSettlementsResponse): unknown {
      const obj: any = {};
      if (message.pendingSettlements?.length) {
        obj.pendingSettlements = message.pendingSettlements.map((e) =>
          PendingSettlement.toJSON(e),
        );
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllPendingSettlementsResponse>, I>>(
      base?: I,
    ): QueryAllPendingSettlementsResponse {
      return QueryAllPendingSettlementsResponse.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<QueryAllPendingSettlementsResponse>, I>,
    >(object: I): QueryAllPendingSettlementsResponse {
      const message = createBaseQueryAllPendingSettlementsResponse();
      message.pendingSettlements =
        object.pendingSettlements?.map((e) =>
          PendingSettlement.fromPartial(e),
        ) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryGetProtocolFeesRequest(): QueryGetProtocolFeesRequest {
  return {};
}

export const QueryGetProtocolFeesRequest: MessageFns<QueryGetProtocolFeesRequest> =
  {
    encode(
      _: QueryGetProtocolFeesRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetProtocolFeesRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetProtocolFeesRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): QueryGetProtocolFeesRequest {
      return {};
    },

    toJSON(_: QueryGetProtocolFeesRequest): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetProtocolFeesRequest>, I>>(
      base?: I,
    ): QueryGetProtocolFeesRequest {
      return QueryGetProtocolFeesRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetProtocolFeesRequest>, I>>(
      _: I,
    ): QueryGetProtocolFeesRequest {
      const message = createBaseQueryGetProtocolFeesRequest();
      return message;
    },
  };

function createBaseQueryGetProtocolFeesResponse(): QueryGetProtocolFeesResponse {
  return { protocolFees: undefined };
}

export const QueryGetProtocolFeesResponse: MessageFns<QueryGetProtocolFeesResponse> =
  {
    encode(
      message: QueryGetProtocolFeesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.protocolFees !== undefined) {
        ProtocolFees.encode(
          message.protocolFees,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetProtocolFeesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetProtocolFeesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.protocolFees = ProtocolFees.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetProtocolFeesResponse {
      return {
        protocolFees: isSet(object.protocolFees)
          ? ProtocolFees.fromJSON(object.protocolFees)
          : undefined,
      };
    },

    toJSON(message: QueryGetProtocolFeesResponse): unknown {
      const obj: any = {};
      if (message.protocolFees !== undefined) {
        obj.protocolFees = ProtocolFees.toJSON(message.protocolFees);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetProtocolFeesResponse>, I>>(
      base?: I,
    ): QueryGetProtocolFeesResponse {
      return QueryGetProtocolFeesResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetProtocolFeesResponse>, I>>(
      object: I,
    ): QueryGetProtocolFeesResponse {
      const message = createBaseQueryGetProtocolFeesResponse();
      message.protocolFees =
        object.protocolFees !== undefined && object.protocolFees !== null
          ? ProtocolFees.fromPartial(object.protocolFees)
          : undefined;
      return message;
    },
  };

function createBaseQueryGetSolverDataRequest(): QueryGetSolverDataRequest {
  return { index: "" };
}

export const QueryGetSolverDataRequest: MessageFns<QueryGetSolverDataRequest> =
  {
    encode(
      message: QueryGetSolverDataRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.index !== "") {
        writer.uint32(10).string(message.index);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetSolverDataRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetSolverDataRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.index = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetSolverDataRequest {
      return {
        index: isSet(object.index) ? globalThis.String(object.index) : "",
      };
    },

    toJSON(message: QueryGetSolverDataRequest): unknown {
      const obj: any = {};
      if (message.index !== "") {
        obj.index = message.index;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetSolverDataRequest>, I>>(
      base?: I,
    ): QueryGetSolverDataRequest {
      return QueryGetSolverDataRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetSolverDataRequest>, I>>(
      object: I,
    ): QueryGetSolverDataRequest {
      const message = createBaseQueryGetSolverDataRequest();
      message.index = object.index ?? "";
      return message;
    },
  };

function createBaseQueryGetSolverDataResponse(): QueryGetSolverDataResponse {
  return { solverData: undefined };
}

export const QueryGetSolverDataResponse: MessageFns<QueryGetSolverDataResponse> =
  {
    encode(
      message: QueryGetSolverDataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.solverData !== undefined) {
        SolverData.encode(message.solverData, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetSolverDataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetSolverDataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.solverData = SolverData.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetSolverDataResponse {
      return {
        solverData: isSet(object.solverData)
          ? SolverData.fromJSON(object.solverData)
          : undefined,
      };
    },

    toJSON(message: QueryGetSolverDataResponse): unknown {
      const obj: any = {};
      if (message.solverData !== undefined) {
        obj.solverData = SolverData.toJSON(message.solverData);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetSolverDataResponse>, I>>(
      base?: I,
    ): QueryGetSolverDataResponse {
      return QueryGetSolverDataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetSolverDataResponse>, I>>(
      object: I,
    ): QueryGetSolverDataResponse {
      const message = createBaseQueryGetSolverDataResponse();
      message.solverData =
        object.solverData !== undefined && object.solverData !== null
          ? SolverData.fromPartial(object.solverData)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllSolverDataRequest(): QueryAllSolverDataRequest {
  return { pagination: undefined };
}

export const QueryAllSolverDataRequest: MessageFns<QueryAllSolverDataRequest> =
  {
    encode(
      message: QueryAllSolverDataRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllSolverDataRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllSolverDataRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllSolverDataRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllSolverDataRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllSolverDataRequest>, I>>(
      base?: I,
    ): QueryAllSolverDataRequest {
      return QueryAllSolverDataRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllSolverDataRequest>, I>>(
      object: I,
    ): QueryAllSolverDataRequest {
      const message = createBaseQueryAllSolverDataRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllSolverDataResponse(): QueryAllSolverDataResponse {
  return { solverData: [], pagination: undefined };
}

export const QueryAllSolverDataResponse: MessageFns<QueryAllSolverDataResponse> =
  {
    encode(
      message: QueryAllSolverDataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.solverData) {
        SolverData.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllSolverDataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllSolverDataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.solverData.push(SolverData.decode(reader, reader.uint32()));
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllSolverDataResponse {
      return {
        solverData: globalThis.Array.isArray(object?.solverData)
          ? object.solverData.map((e: any) => SolverData.fromJSON(e))
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllSolverDataResponse): unknown {
      const obj: any = {};
      if (message.solverData?.length) {
        obj.solverData = message.solverData.map((e) => SolverData.toJSON(e));
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllSolverDataResponse>, I>>(
      base?: I,
    ): QueryAllSolverDataResponse {
      return QueryAllSolverDataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllSolverDataResponse>, I>>(
      object: I,
    ): QueryAllSolverDataResponse {
      const message = createBaseQueryAllSolverDataResponse();
      message.solverData =
        object.solverData?.map((e) => SolverData.fromPartial(e)) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryGetSettlementRequest(): QueryGetSettlementRequest {
  return { id: Long.UZERO };
}

export const QueryGetSettlementRequest: MessageFns<QueryGetSettlementRequest> =
  {
    encode(
      message: QueryGetSettlementRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetSettlementRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetSettlementRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetSettlementRequest {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: QueryGetSettlementRequest): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetSettlementRequest>, I>>(
      base?: I,
    ): QueryGetSettlementRequest {
      return QueryGetSettlementRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetSettlementRequest>, I>>(
      object: I,
    ): QueryGetSettlementRequest {
      const message = createBaseQueryGetSettlementRequest();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseQueryGetSettlementResponse(): QueryGetSettlementResponse {
  return { settlement: undefined };
}

export const QueryGetSettlementResponse: MessageFns<QueryGetSettlementResponse> =
  {
    encode(
      message: QueryGetSettlementResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.settlement !== undefined) {
        Settlement.encode(message.settlement, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryGetSettlementResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryGetSettlementResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.settlement = Settlement.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryGetSettlementResponse {
      return {
        settlement: isSet(object.settlement)
          ? Settlement.fromJSON(object.settlement)
          : undefined,
      };
    },

    toJSON(message: QueryGetSettlementResponse): unknown {
      const obj: any = {};
      if (message.settlement !== undefined) {
        obj.settlement = Settlement.toJSON(message.settlement);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryGetSettlementResponse>, I>>(
      base?: I,
    ): QueryGetSettlementResponse {
      return QueryGetSettlementResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryGetSettlementResponse>, I>>(
      object: I,
    ): QueryGetSettlementResponse {
      const message = createBaseQueryGetSettlementResponse();
      message.settlement =
        object.settlement !== undefined && object.settlement !== null
          ? Settlement.fromPartial(object.settlement)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllSettlementRequest(): QueryAllSettlementRequest {
  return { pagination: undefined };
}

export const QueryAllSettlementRequest: MessageFns<QueryAllSettlementRequest> =
  {
    encode(
      message: QueryAllSettlementRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.pagination !== undefined) {
        PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllSettlementRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllSettlementRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.pagination = PageRequest.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllSettlementRequest {
      return {
        pagination: isSet(object.pagination)
          ? PageRequest.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllSettlementRequest): unknown {
      const obj: any = {};
      if (message.pagination !== undefined) {
        obj.pagination = PageRequest.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllSettlementRequest>, I>>(
      base?: I,
    ): QueryAllSettlementRequest {
      return QueryAllSettlementRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllSettlementRequest>, I>>(
      object: I,
    ): QueryAllSettlementRequest {
      const message = createBaseQueryAllSettlementRequest();
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageRequest.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseQueryAllSettlementResponse(): QueryAllSettlementResponse {
  return { settlement: [], pagination: undefined };
}

export const QueryAllSettlementResponse: MessageFns<QueryAllSettlementResponse> =
  {
    encode(
      message: QueryAllSettlementResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.settlement) {
        Settlement.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.pagination !== undefined) {
        PageResponse.encode(
          message.pagination,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryAllSettlementResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryAllSettlementResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.settlement.push(Settlement.decode(reader, reader.uint32()));
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.pagination = PageResponse.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryAllSettlementResponse {
      return {
        settlement: globalThis.Array.isArray(object?.settlement)
          ? object.settlement.map((e: any) => Settlement.fromJSON(e))
          : [],
        pagination: isSet(object.pagination)
          ? PageResponse.fromJSON(object.pagination)
          : undefined,
      };
    },

    toJSON(message: QueryAllSettlementResponse): unknown {
      const obj: any = {};
      if (message.settlement?.length) {
        obj.settlement = message.settlement.map((e) => Settlement.toJSON(e));
      }
      if (message.pagination !== undefined) {
        obj.pagination = PageResponse.toJSON(message.pagination);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<QueryAllSettlementResponse>, I>>(
      base?: I,
    ): QueryAllSettlementResponse {
      return QueryAllSettlementResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<QueryAllSettlementResponse>, I>>(
      object: I,
    ): QueryAllSettlementResponse {
      const message = createBaseQueryAllSettlementResponse();
      message.settlement =
        object.settlement?.map((e) => Settlement.fromPartial(e)) || [];
      message.pagination =
        object.pagination !== undefined && object.pagination !== null
          ? PageResponse.fromPartial(object.pagination)
          : undefined;
      return message;
    },
  };

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(
    message: MsgUpdateParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority)
        ? globalThis.String(object.authority)
        : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(
    base?: I,
  ): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(
    object: I,
  ): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(
    _: MsgUpdateParamsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgUpdateParamsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(
    base?: I,
  ): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(
    _: I,
  ): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgCreateRequestForFunds(): MsgCreateRequestForFunds {
  return {
    user: "",
    sources: [],
    destinationUniverse: 0,
    destinationChainID: new Uint8Array(0),
    recipientAddress: new Uint8Array(0),
    destinations: [],
    nonce: new Uint8Array(0),
    expiry: Long.UZERO,
    signatureData: [],
  };
}

export const MsgCreateRequestForFunds: MessageFns<MsgCreateRequestForFunds> = {
  encode(
    message: MsgCreateRequestForFunds,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== "") {
      writer.uint32(58).string(message.user);
    }
    for (const v of message.sources) {
      RFFSourcePair.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.destinationUniverse !== 0) {
      writer.uint32(16).int32(message.destinationUniverse);
    }
    if (message.destinationChainID.length !== 0) {
      writer.uint32(26).bytes(message.destinationChainID);
    }
    if (message.recipientAddress.length !== 0) {
      writer.uint32(74).bytes(message.recipientAddress);
    }
    for (const v of message.destinations) {
      RFFDestinationPair.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.expiry.toString());
    }
    for (const v of message.signatureData) {
      SignatureDatum.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgCreateRequestForFunds {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateRequestForFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sources.push(RFFSourcePair.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.destinationUniverse = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationChainID = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.recipientAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinations.push(
            RFFDestinationPair.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiry = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.signatureData.push(
            SignatureDatum.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateRequestForFunds {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => RFFSourcePair.fromJSON(e))
        : [],
      destinationUniverse: isSet(object.destinationUniverse)
        ? universeFromJSON(object.destinationUniverse)
        : 0,
      destinationChainID: isSet(object.destinationChainID)
        ? bytesFromBase64(object.destinationChainID)
        : new Uint8Array(0),
      recipientAddress: isSet(object.recipientAddress)
        ? bytesFromBase64(object.recipientAddress)
        : new Uint8Array(0),
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => RFFDestinationPair.fromJSON(e))
        : [],
      nonce: isSet(object.nonce)
        ? bytesFromBase64(object.nonce)
        : new Uint8Array(0),
      expiry: isSet(object.expiry) ? Long.fromValue(object.expiry) : Long.UZERO,
      signatureData: globalThis.Array.isArray(object?.signatureData)
        ? object.signatureData.map((e: any) => SignatureDatum.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgCreateRequestForFunds): unknown {
    const obj: any = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => RFFSourcePair.toJSON(e));
    }
    if (message.destinationUniverse !== 0) {
      obj.destinationUniverse = universeToJSON(message.destinationUniverse);
    }
    if (message.destinationChainID.length !== 0) {
      obj.destinationChainID = base64FromBytes(message.destinationChainID);
    }
    if (message.recipientAddress.length !== 0) {
      obj.recipientAddress = base64FromBytes(message.recipientAddress);
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) =>
        RFFDestinationPair.toJSON(e),
      );
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (!message.expiry.equals(Long.UZERO)) {
      obj.expiry = (message.expiry || Long.UZERO).toString();
    }
    if (message.signatureData?.length) {
      obj.signatureData = message.signatureData.map((e) =>
        SignatureDatum.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateRequestForFunds>, I>>(
    base?: I,
  ): MsgCreateRequestForFunds {
    return MsgCreateRequestForFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateRequestForFunds>, I>>(
    object: I,
  ): MsgCreateRequestForFunds {
    const message = createBaseMsgCreateRequestForFunds();
    message.user = object.user ?? "";
    message.sources =
      object.sources?.map((e) => RFFSourcePair.fromPartial(e)) || [];
    message.destinationUniverse = object.destinationUniverse ?? 0;
    message.destinationChainID = object.destinationChainID ?? new Uint8Array(0);
    message.recipientAddress = object.recipientAddress ?? new Uint8Array(0);
    message.destinations =
      object.destinations?.map((e) => RFFDestinationPair.fromPartial(e)) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.expiry =
      object.expiry !== undefined && object.expiry !== null
        ? Long.fromValue(object.expiry)
        : Long.UZERO;
    message.signatureData =
      object.signatureData?.map((e) => SignatureDatum.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgCreateRequestForFundsResponse(): MsgCreateRequestForFundsResponse {
  return { id: Long.UZERO };
}

export const MsgCreateRequestForFundsResponse: MessageFns<MsgCreateRequestForFundsResponse> =
  {
    encode(
      message: MsgCreateRequestForFundsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgCreateRequestForFundsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreateRequestForFundsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MsgCreateRequestForFundsResponse {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: MsgCreateRequestForFundsResponse): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreateRequestForFundsResponse>, I>>(
      base?: I,
    ): MsgCreateRequestForFundsResponse {
      return MsgCreateRequestForFundsResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<MsgCreateRequestForFundsResponse>, I>,
    >(object: I): MsgCreateRequestForFundsResponse {
      const message = createBaseMsgCreateRequestForFundsResponse();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseMsgCreatePendingClaim(): MsgCreatePendingClaim {
  return { creator: "", claim: undefined };
}

export const MsgCreatePendingClaim: MessageFns<MsgCreatePendingClaim> = {
  encode(
    message: MsgCreatePendingClaim,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.claim !== undefined) {
      BasicClaim.encode(message.claim, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgCreatePendingClaim {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreatePendingClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claim = BasicClaim.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreatePendingClaim {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      claim: isSet(object.claim)
        ? BasicClaim.fromJSON(object.claim)
        : undefined,
    };
  },

  toJSON(message: MsgCreatePendingClaim): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.claim !== undefined) {
      obj.claim = BasicClaim.toJSON(message.claim);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreatePendingClaim>, I>>(
    base?: I,
  ): MsgCreatePendingClaim {
    return MsgCreatePendingClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreatePendingClaim>, I>>(
    object: I,
  ): MsgCreatePendingClaim {
    const message = createBaseMsgCreatePendingClaim();
    message.creator = object.creator ?? "";
    message.claim =
      object.claim !== undefined && object.claim !== null
        ? BasicClaim.fromPartial(object.claim)
        : undefined;
    return message;
  },
};

function createBaseMsgCreatePendingClaimResponse(): MsgCreatePendingClaimResponse {
  return { id: Long.UZERO };
}

export const MsgCreatePendingClaimResponse: MessageFns<MsgCreatePendingClaimResponse> =
  {
    encode(
      message: MsgCreatePendingClaimResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.id.equals(Long.UZERO)) {
        writer.uint32(8).uint64(message.id.toString());
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgCreatePendingClaimResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreatePendingClaimResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = Long.fromString(reader.uint64().toString(), true);
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MsgCreatePendingClaimResponse {
      return { id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO };
    },

    toJSON(message: MsgCreatePendingClaimResponse): unknown {
      const obj: any = {};
      if (!message.id.equals(Long.UZERO)) {
        obj.id = (message.id || Long.UZERO).toString();
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreatePendingClaimResponse>, I>>(
      base?: I,
    ): MsgCreatePendingClaimResponse {
      return MsgCreatePendingClaimResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgCreatePendingClaimResponse>, I>>(
      object: I,
    ): MsgCreatePendingClaimResponse {
      const message = createBaseMsgCreatePendingClaimResponse();
      message.id =
        object.id !== undefined && object.id !== null
          ? Long.fromValue(object.id)
          : Long.UZERO;
      return message;
    },
  };

function createBaseMsgProcessPendingClaim(): MsgProcessPendingClaim {
  return {
    creator: "",
    claimId: Long.UZERO,
    verdict: undefined,
    signature: new Uint8Array(0),
  };
}

export const MsgProcessPendingClaim: MessageFns<MsgProcessPendingClaim> = {
  encode(
    message: MsgProcessPendingClaim,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (!message.claimId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.claimId.toString());
    }
    if (message.verdict !== undefined) {
      ClaimVerdict.encode(message.verdict, writer.uint32(26).fork()).join();
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgProcessPendingClaim {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProcessPendingClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.claimId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verdict = ClaimVerdict.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProcessPendingClaim {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      claimId: isSet(object.claimId)
        ? Long.fromValue(object.claimId)
        : Long.UZERO,
      verdict: isSet(object.verdict)
        ? ClaimVerdict.fromJSON(object.verdict)
        : undefined,
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgProcessPendingClaim): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (!message.claimId.equals(Long.UZERO)) {
      obj.claimId = (message.claimId || Long.UZERO).toString();
    }
    if (message.verdict !== undefined) {
      obj.verdict = ClaimVerdict.toJSON(message.verdict);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProcessPendingClaim>, I>>(
    base?: I,
  ): MsgProcessPendingClaim {
    return MsgProcessPendingClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProcessPendingClaim>, I>>(
    object: I,
  ): MsgProcessPendingClaim {
    const message = createBaseMsgProcessPendingClaim();
    message.creator = object.creator ?? "";
    message.claimId =
      object.claimId !== undefined && object.claimId !== null
        ? Long.fromValue(object.claimId)
        : Long.UZERO;
    message.verdict =
      object.verdict !== undefined && object.verdict !== null
        ? ClaimVerdict.fromPartial(object.verdict)
        : undefined;
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgProcessPendingClaimResponse(): MsgProcessPendingClaimResponse {
  return {};
}

export const MsgProcessPendingClaimResponse: MessageFns<MsgProcessPendingClaimResponse> =
  {
    encode(
      _: MsgProcessPendingClaimResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgProcessPendingClaimResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgProcessPendingClaimResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgProcessPendingClaimResponse {
      return {};
    },

    toJSON(_: MsgProcessPendingClaimResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgProcessPendingClaimResponse>, I>>(
      base?: I,
    ): MsgProcessPendingClaimResponse {
      return MsgProcessPendingClaimResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<MsgProcessPendingClaimResponse>, I>,
    >(_: I): MsgProcessPendingClaimResponse {
      const message = createBaseMsgProcessPendingClaimResponse();
      return message;
    },
  };

function createBaseMsgUpsertProtocolFees(): MsgUpsertProtocolFees {
  return {
    creator: "",
    feeBP: Long.UZERO,
    collectionFees: [],
    fulfilmentFees: [],
    feeRecipients: [],
  };
}

export const MsgUpsertProtocolFees: MessageFns<MsgUpsertProtocolFees> = {
  encode(
    message: MsgUpsertProtocolFees,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (!message.feeBP.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.feeBP.toString());
    }
    for (const v of message.collectionFees) {
      FixedFeeTuple.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.fulfilmentFees) {
      FixedFeeTuple.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.feeRecipients) {
      AdminFeeRecipient.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgUpsertProtocolFees {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpsertProtocolFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feeBP = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collectionFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fulfilmentFees.push(
            FixedFeeTuple.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feeRecipients.push(
            AdminFeeRecipient.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpsertProtocolFees {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      feeBP: isSet(object.feeBP) ? Long.fromValue(object.feeBP) : Long.UZERO,
      collectionFees: globalThis.Array.isArray(object?.collectionFees)
        ? object.collectionFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      fulfilmentFees: globalThis.Array.isArray(object?.fulfilmentFees)
        ? object.fulfilmentFees.map((e: any) => FixedFeeTuple.fromJSON(e))
        : [],
      feeRecipients: globalThis.Array.isArray(object?.feeRecipients)
        ? object.feeRecipients.map((e: any) => AdminFeeRecipient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpsertProtocolFees): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (!message.feeBP.equals(Long.UZERO)) {
      obj.feeBP = (message.feeBP || Long.UZERO).toString();
    }
    if (message.collectionFees?.length) {
      obj.collectionFees = message.collectionFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.fulfilmentFees?.length) {
      obj.fulfilmentFees = message.fulfilmentFees.map((e) =>
        FixedFeeTuple.toJSON(e),
      );
    }
    if (message.feeRecipients?.length) {
      obj.feeRecipients = message.feeRecipients.map((e) =>
        AdminFeeRecipient.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpsertProtocolFees>, I>>(
    base?: I,
  ): MsgUpsertProtocolFees {
    return MsgUpsertProtocolFees.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpsertProtocolFees>, I>>(
    object: I,
  ): MsgUpsertProtocolFees {
    const message = createBaseMsgUpsertProtocolFees();
    message.creator = object.creator ?? "";
    message.feeBP =
      object.feeBP !== undefined && object.feeBP !== null
        ? Long.fromValue(object.feeBP)
        : Long.UZERO;
    message.collectionFees =
      object.collectionFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.fulfilmentFees =
      object.fulfilmentFees?.map((e) => FixedFeeTuple.fromPartial(e)) || [];
    message.feeRecipients =
      object.feeRecipients?.map((e) => AdminFeeRecipient.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpsertProtocolFeesResponse(): MsgUpsertProtocolFeesResponse {
  return {};
}

export const MsgUpsertProtocolFeesResponse: MessageFns<MsgUpsertProtocolFeesResponse> =
  {
    encode(
      _: MsgUpsertProtocolFeesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgUpsertProtocolFeesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgUpsertProtocolFeesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgUpsertProtocolFeesResponse {
      return {};
    },

    toJSON(_: MsgUpsertProtocolFeesResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgUpsertProtocolFeesResponse>, I>>(
      base?: I,
    ): MsgUpsertProtocolFeesResponse {
      return MsgUpsertProtocolFeesResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgUpsertProtocolFeesResponse>, I>>(
      _: I,
    ): MsgUpsertProtocolFeesResponse {
      const message = createBaseMsgUpsertProtocolFeesResponse();
      return message;
    },
  };

function createBaseMsgUpsertSolverData(): MsgUpsertSolverData {
  return { cosmosAddress: "", advertisedFees: [], addresses: [] };
}

export const MsgUpsertSolverData: MessageFns<MsgUpsertSolverData> = {
  encode(
    message: MsgUpsertSolverData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cosmosAddress !== "") {
      writer.uint32(10).string(message.cosmosAddress);
    }
    for (const v of message.advertisedFees) {
      RouteFee.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.addresses) {
      SolverAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MsgUpsertSolverData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpsertSolverData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cosmosAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.advertisedFees.push(RouteFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(SolverAddress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpsertSolverData {
    return {
      cosmosAddress: isSet(object.cosmosAddress)
        ? globalThis.String(object.cosmosAddress)
        : "",
      advertisedFees: globalThis.Array.isArray(object?.advertisedFees)
        ? object.advertisedFees.map((e: any) => RouteFee.fromJSON(e))
        : [],
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => SolverAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpsertSolverData): unknown {
    const obj: any = {};
    if (message.cosmosAddress !== "") {
      obj.cosmosAddress = message.cosmosAddress;
    }
    if (message.advertisedFees?.length) {
      obj.advertisedFees = message.advertisedFees.map((e) =>
        RouteFee.toJSON(e),
      );
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => SolverAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpsertSolverData>, I>>(
    base?: I,
  ): MsgUpsertSolverData {
    return MsgUpsertSolverData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpsertSolverData>, I>>(
    object: I,
  ): MsgUpsertSolverData {
    const message = createBaseMsgUpsertSolverData();
    message.cosmosAddress = object.cosmosAddress ?? "";
    message.advertisedFees =
      object.advertisedFees?.map((e) => RouteFee.fromPartial(e)) || [];
    message.addresses =
      object.addresses?.map((e) => SolverAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpsertSolverDataResponse(): MsgUpsertSolverDataResponse {
  return {};
}

export const MsgUpsertSolverDataResponse: MessageFns<MsgUpsertSolverDataResponse> =
  {
    encode(
      _: MsgUpsertSolverDataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): MsgUpsertSolverDataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgUpsertSolverDataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgUpsertSolverDataResponse {
      return {};
    },

    toJSON(_: MsgUpsertSolverDataResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgUpsertSolverDataResponse>, I>>(
      base?: I,
    ): MsgUpsertSolverDataResponse {
      return MsgUpsertSolverDataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgUpsertSolverDataResponse>, I>>(
      _: I,
    ): MsgUpsertSolverDataResponse {
      const message = createBaseMsgUpsertSolverDataResponse();
      return message;
    },
  };

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends { $case: string; value: unknown }
          ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
          : T extends {}
            ? { [K in keyof T]?: DeepPartial<T[K]> }
            : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
